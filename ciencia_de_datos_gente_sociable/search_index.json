[
["index.html", "Ciencia de Datos para Gente Sociable Antes de empezar", " Ciencia de Datos para Gente Sociable Una introducción a la exploración, análisis y visualización de datos Antonio Vazquez Brust 2018-01-30 Antes de empezar Para practicar con los ejemplos que se explicarán a lo largo del documento, es necesario instalar el lenguaje de programación R, y la interfaz gráfica RStudio Desktop. "],
["que-es-la-ciencia-de-datos.html", "Capítulo 1 ¿Qué es la ciencia de datos?", " Capítulo 1 ¿Qué es la ciencia de datos? "],
["una-presentacion-a-toda-marcha-de-r.html", "Capítulo 2 Una presentación a toda marcha de R 2.1 A investigar: ¿Cual es la diferencia en mortalidad infantil entre el sur y el norte de la Ciudad Autónoma de Buenos Aires? 2.2 Nuestro primer proyecto en R 2.3 Escribiendo un script 2.4 Visualización: la exploración gráfica de la información 2.5 Haciendo mapas 2.6 Agregando datos 2.7 El veredicto final 2.8 ¿Cuál es la diferencia en mortalidad infantil entre el sur y el norte de la Ciudad Autónoma de Buenos Aires?", " Capítulo 2 Una presentación a toda marcha de R R es un lenguaje de programación especializado en análisis y visualización de datos. Es un producto de código abierto, lo cual significa que cualquier persona puede usarlo y modificarlo sin pagar licencias ni costos de adquisición de ningún tipo. Expertos de todo el mundo colaboran en forma activa con el proyecto, no sólo desarrollando el lenguaje en sí (llamado “R base”), sino también extendiéndolo con nuevas habilidades que pueden ser incorporadas por los usuarios finales en forma de “paquetes” de funciones que pueden ser instaladas. La calidad del lenguaje en sí, de los paquetes instalables que le agregan un sinfín de funciones (desde algoritmos de inteligencia artificial hasta la generación de mapas interactivos) y de la comunidad de usuarios que comparte información en foros y blogs, ha hecho de R uno de los lenguajes de programación más populares del mundo. En el campo del análisis de datos, es la herramienta por excelencia en muchas universidades, empresas de tecnología, y redacciones de periodismo de datos. 2.1 A investigar: ¿Cual es la diferencia en mortalidad infantil entre el sur y el norte de la Ciudad Autónoma de Buenos Aires? Buenos Aires es una ciudad que desde hace décadas presenta una marcada polarización entre sus barrios del sur, relativamente menos desarrollados, y los del norte donde el nivel socioeconómico y la calidad de vida son mayores. Figura 2.1: Artículo en la edición online de El País Uno de los aspectos más lamentables de la disparidad norte-sur, y sin duda de los que más polémica y acusaciones cruzadas ha generado, es la diferencia en la tasa de mortalidad infantil de acuerdo a la región de la ciudad. ¿Qué tan grande es esa diferencia? ¿Cómo se distribuye geográficamente? Vamos a utilizar R para responder esas preguntas y visualizar los resultados de nuestro análisis, utilizando como fuente cifras oficiales publicada por la ciudad. 2.2 Nuestro primer proyecto en R A continuación reproduciremos un ejercicio paso a paso, para ilustrar la potencia de una herramienta de análisis como R. Que nadie se preocupe si algunas de las operaciones parecen no tener sentido, o resultan arbitrarias. ¡Es normal! Nadie aprende un lenguaje en 10 minutos, sea R o esperanto. La idea es tener exposición temprana a un caso de uso interesante, usando datos reales. Y que nos sirva como motivación para practicar luego ejercicios básicos que son muy necesarios pero, a veces, no tan emocionantes. 2.2.1 Crear un proyecto en RStudio El primer paso es ejecutar RStudio, que ya deberíamos tener disponible en nuestro sistema. Una vez abierta la interfaz gráfica, creamos un proyecto nuevo, cliqueando en File -&gt; New Project... -&gt; New Directory -&gt; New Project. En la ventana que surge, elegir un nombre para el proyecto (por ejemplo, “Practicando R”) y finalizar la operación cliqueando en Create project. Utilizar proyectos nos permite continuar otro día desde donde dejamos la tarea al terminar una sesión. Es sólo cuestión de recuperar el proyecto deseado la próxima vez que abrimos RStudio, cliqueando en File -&gt; Recent Projects -&gt; &quot;nombre de mi proyecto&quot;. Por ahora, sigamos trabajando. Vamos a crear un “script”. Un script, como su nombre en inglés lo indica, es un guión; una serie de pasos que escribimos para que nuestra computadora ejecute en secuencia. Cliqueamos en File -&gt; New File -&gt; R Script. De inmediato se abre una ventana con un editor de texto. ¡Ahora empieza la acción! 2.3 Escribiendo un script Aprovechemos para dar un nombre a los áreas que vemos en RStudio: Figura 2.2: La interfaz de RStudio Vamos a escribir nuestro código (las instrucciones que R entiende) en el panel de edición. Los resultados van a aparecer en la consola (cuando se trate de texto) o en el panel de salida (cuando produzcamos gráficos) Por ejemplo, podemos escribir el panel de edición la instrucción para mostrar el resultado de una operación matemático: sqrt(144) sqrt() es una función. En el mundo de la programación, las funciones son secuencias de código ya listas para usar, que realizan tareas útiles. Por ejemplo, mostrar algo en pantalla. En nuestro caso, completamos la función con algo más: un parámetro, pues así se le llama a los valores que una función espera de parte del usuario para saber que hacer. La función print espera que le demos un número para el cual calcular su raíz cuadrada (square root en inglés), y eso hicimos: le pasamos cómo parámetro 144, un número. Los parámetros siempre se escriben entre paréntesis, a continuación del nombre de la función. Ahora vamos a aprender la combinación de teclas más importante al usar RStudio: Ctrl + Enter. Presionar Ctrl + Enter al terminar de escribir una instrucción hace que RStudio la ejecute de inmediato, y espere en la siguiente instrucción, si la hubiera. Cambien podemos buscar una línea que deseemos ejecutar, posicionando el cursor de texto (que luce como una barra vertical que titila, en el panel de edición) sobre ella. Si a continuación pulsamos Ctrl + Enter, la línea será ejecutada y el cursor se moverá sólo hasta la siguiente línea, listo para repetir el proceso. La modalidad de ejecución línea por línea es muy útil para lo que se llama “análisis interactivo”. Uno ejecuta un comando, observa el resultado, y en base a eso decide su próxima acción: cambiar parámetros e intentarlo de nuevo, dar por buenos los resultados y usarlos para una tarea subsiguiente… etc. Por ejemplo, si escribimos las siguientes líneas: sqrt(144) mensaje &lt;- &quot;Hola mundo&quot; mensaje …y posicionamos el cursor en cualquier posición de la primera línea, para luego pulsar Ctrl + Enter tres veces, veremos que las instrucciones son ejecutadas línea a línea. sqrt(144) ## [1] 12 mensaje &lt;- &quot;Hola mundo&quot; mensaje ## [1] &quot;Hola mundo&quot; Dos de ellas (la primera y la última) mostraron una salida en pantalla, y la del medio, no. Esto es porque algunas funciones entregan algo como resultado algo -un número, un texto, un gráfico, u otros tipos de salida que ya veremos- mientras que otras hacen su tarea silenciosamente sin expresar nada. En este caso, la función silenciosa fue la de asignación: mensaje &lt;- &quot;Hola mundo&quot; es una instrucción que le pide a R que cree una variable llamada “mensaje” (o que la encuentre si ya existe) y que le asigne como valor el texto “Hola mundo”. ¿Cómo sabemos que la instrucción se llevó a cabo, a pesar de no producir una salida? En general, es un tema de confianza. Si una instrucción no genera un mensaje de error, si es silenciosa, se asume que pudo cumplir su cometido. En este caso, además lo hemos verificado. La línea final, mensaje pide a R que busque la variable, y muestre en pantalla su contenido (esa es una característica muy práctica del lenguaje: para saber el contenido de una variable, basta con escribirla y ejecutar la línea). Y al hacerlo, comprobamos que la variable contiene precisamente lo que hemos tipeado. De paso, hay que mencionar que la creación y manipulación de variables es un concepto clave en programación. Trabajar con variables nos permite almacenar valores para usarlos después, además de hacer nuestro código más fácil de leer y compartir con otros, en especial cuando usamos nombre de variable auto-explicativos. Como ejemplo de ésto ultimo comparemos x &lt;- 8 * 6 x ## [1] 48 … con ancho_habitacion_m &lt;- 8 profundiad_habitacion_m &lt;- 6 superficie_habitacion_m2 &lt;- ancho_habitacion_m * profundiad_habitacion_m superficie_habitacion_m2 ## [1] 48 En su resultado ambas expresiones son iguales, ya que llegan producen lo mismo. Pero la segunda esta escrita de una forma mucho más clara en lo a un ser humano respecta, que hace más fácil interpretar su lógica… ¡está calculando la superficie en metros cuadrados de una habitación!. Es muy importante escribir nuestro código de la forma más clara posible, aunque requiera tipear un poco más. Con ello, no sólo le hacemos la vida más fácil a otras personas que interpreten nuestros programas, sino también a nosotros mismos en el futuro, cuando debamos lidiar con un programa que escribimos tiempo atrás y del que a duras penas recordamos su lógica. A todo esto… ¿no se suponía que íbamos a investigar la mortalidad infantil en la Ciudad de Buenos Aires?. Suficiente introducción… ¡allá vamos! 2.3.1 Cargar los datos Vamos a cargar datos de mortalidad infantil, por comuna de la ciudad, en el año 2016, publicados por la Dirección General de Estadística y Censos de Buenos Aires. El formato original de los datos es “.xls” (planilla de hojas de cálculo). Yo lo he convertido a .csv (“comma separated values”) un formato muy popular en el mundo de la ciencia de datos, ya que es muy fácil de manipular y compartir entre sistemas… es posible abrir un archivo .csv hasta con el humilde block de notas. Al igual que los archivos .xls, los .csv se utilizan para guardar información tabular: un rectángulo con filas y columnas. R incluye una función que lee archivos .csv, que se llama read.csv. La usamos así: mortalidad &lt;- read.csv(&#39;https://bitsandbricks.github.io/data/mortalidad_infantil_caba_2016.csv&#39;) Obsérvese que los datos están alojados en un servidor de internet (accesibles vía https://bitsandbricks…). Eso no es problema para la función read.csv, que con la misma soltura lee archivos guardados en nuestra PC o publicados en un sitio web. Para ver el contenido de la variable donde guardamos el resultado de leer la data, mortalidad, sólo hace falta escribir su nombre: mortalidad ## Comuna Tasa2016 ## 1 1 9.5 ## 2 2 3.6 ## 3 3 8.0 ## 4 4 11.9 ## 5 5 8.5 ## 6 6 2.4 ## 7 7 8.5 ## 8 8 9.7 ## 9 9 10.1 ## 10 10 3.6 ## 11 11 6.2 ## 12 12 7.1 ## 13 13 4.5 ## 14 14 3.2 ## 15 15 6.4 Vemos que la tabla tiene 15 columnas (una por cada comuna de la ciudad) y 7 columnas (una que indica la comuna, y 6 con los valores de mortalidad para cada año entre 2010 y 2017). En R, las tablas son llamadas dataframes. El dataframe es el objeto por excelencia del análisis de datos. En concepto, es muy similar a una tabla de excel; al fin y al cabo, ambos formatos guardan información en celdas identificadas por fila y columna. Algunas funciones útiles para explorar un dataframe que no conocemos son dim(), que nos da las dimensiones del dataframe (cantidad de filas y columnas), names() que nos dice como se llaman sus columnas (que en general representan variables), y head() que nos permite echar un vistazo rápido al contenido, mostrando sólo las seis primeras filas (ésto es útil porque con frecuencia trabajamos con dataframes que contienen miles o millones de filas, con lo que no tiene sentido tratar de volcar todas en pantalla). dim(mortalidad) ## [1] 15 2 names(mortalidad) ## [1] &quot;Comuna&quot; &quot;Tasa2016&quot; head(mortalidad) ## Comuna Tasa2016 ## 1 1 9.5 ## 2 2 3.6 ## 3 3 8.0 ## 4 4 11.9 ## 5 5 8.5 ## 6 6 2.4 2.4 Visualización: la exploración gráfica de la información Ahora es vamos a pisar el acelerador. Insisto: nadie debe preocuparse si algunos conceptos parecen ser demasiado complejos. En las próximas secciones practicaremos de forma gradual las técnicas que vamos a usar ahora, y todo tendrá sentido -¡lo prometo!. Pero antes, seamos un poquito irresponsables con el poder de R y empleemos un arsenal sofisticado de herramientas para ver de que somos capaces. En la introducción hablamos de los paquetes, conjuntos de programas que extienden la funcionalidad de R. Vamos a cargar uno de los paquetes más usados, tidyverse. Tidyverse incluye una gran cantidad de funciones diseñadas por y para practicantes de la ciencia de datos. Estas funciones comparten una filosofía y una sintaxis común, por lo que al aprender una en cierto modo aprendemos a usar todas. El valor que aportan es que, sin dudas, ayudan a realizar de manera más fácil las tareas típicas de la ciencia de datos: importar, limpiar, comprender y comunicar datos. Si acabamos de instalar R y RStudio, el paquete aún no estará disponible en nuestro sistema. Para instalarlo, usamos la función install.packages() y le pasamos el nombre del paquete deseado, “tidyverse”, entre comillas. install.packages(&quot;tidyverse&quot;) De aquí en más, podremos usar el paquete cada vez que queramos. Para eso, lo invocamos con la función library(): library(tidyverse) … y listo para usar. La razón por la cual activamos tidyverse es que en este momento nos vienen bien dos de sus funciones: mutate() para modificar valores, y ggplot() para hacer gráficos. Bien, llega la hora de los gráficos. Vamos a llamar a la función ggplot(), una auténtica navaja suiza para la visualización. Por ejemplo, veamos a cuanto asciende la tasa de mortalidad infantil en cada comuna durante 2016: ggplot(mortalidad) + geom_col(aes(x = factor(Comuna), y = Tasa2016)) Para realizar una visualización con ésta herramienta, siempre se comienza con la función ggplot(), que crea un eje de coordenadas sobre el cual se pueden agregar capas. El primer parámetro que recibe ggplot() es el dataset que queremos usar para el gráfico; en nuestro caso, ggplot(mortalidad). Ejecutar sólo ggplot(mortalidad) nos devuelve un gráfico vacío; la gracia está en agregar una o más capas especificando cómo queremos mostrar los datos. Estas capas se agregan con un signo +. En nuestro ejemplo, geom_col() crea columnas cuya posición en el eje de las x depende de la variable “Comuna”, mientas que la altura (posición en el eje de las y) depende del valor de la variable “Tasa2016”. Existen muchas funciones de tipo “geom_XXX”, que agregan distintas clases de capas al gráfico: geom_point, geom_polygon, geom_text y muchos, muchos más que iremos viendo más adelante. Cada función “geom_” toma como parámetro un conjunto de definiciones “estéticas” que le indican una variable a graficar (“mortalidad” en nuestro caso), cómo (color, tamaño, etc) y dónde (posición x, posición y del eje). Estos parámetros van siempre dentro de una función auxiliar, aes(). En nuestro ejemplo, “geom_line(aes(x = año, y = mortalidad, group = Comuna, color = factor(Comuna)))”. No se preocupen que iremos practicando el uso de ggplot, y su uso se volverá familiar. En cuanto al gráfico que hemos creado, podemos observar que entre las 15 comunas en la ciudad, la tasa de mortalidad tiene un rango que va de un poco menos de 2,5 a un poco más de 12,5 (esto es, muertes antes del año de vida por cada 10.000 nacimientos). Pero no se distingue aquello que queríamos comprender: la diferencia entre el norte y el sur de la ciudad. Necesitamos contexto geográfico. 2.5 Haciendo mapas Vamos a presentar un paquete más, el último para éste capítulo: sf. Quizás algunos tengan experiencia con sistemas de información geográfica (GIS por sus siglas en inglés), al estilo de QGIS o ArcGIS, que permiten crear, manipular y combinar archivos con datos espaciales para producir mapas que pueden ser simples o en extremo sofisticados. En R, el paquete sf brinda herramientas que permiten realizar tares similares. Nuestro objetivo es obtener un mapa de la ciudad de Buenos Aires con sus comunas. Primero, instalamos sf en caso de que aún no lo hayamos hecho. Sólo es necesario hacerlo una vez: install.packages(&quot;sf&quot;) Pedimos a R que active el paquete: library(sf) Y cargamos un archivo georeferenciado con las comunas de la Ciudad Autónoma de Buenos Aires, disponible online en formato geojson, un estándar de representación de datos geográficos que es fácil de usar: comunas &lt;- st_read(&#39;https://bitsandbricks.github.io/data/CABA_comunas.geojson&#39;) ## Reading layer `OGRGeoJSON&#39; from data source `https://bitsandbricks.github.io/data/CABA_comunas.geojson&#39; using driver `GeoJSON&#39; ## Simple feature collection with 15 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -58.53152 ymin: -34.70529 xmax: -58.33514 ymax: -34.52754 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs Al igual que cuando usamos read.csv() para leer un archivo .csv y cargarlo como un dataframe, el comando st_read() hace lo propio con archivos de información geográfica, conocidos en la jerga como “shapefiles”. El resultado también es un dataframe, por lo cual podemos practicar el uso de las funciones que ya aprendimos, como dim(), names() y head(). dim(comunas) ## [1] 15 5 names(comunas) ## [1] &quot;barrios&quot; &quot;perimetro&quot; &quot;area&quot; &quot;comunas&quot; &quot;geometry&quot; head(comunas) ## Simple feature collection with 6 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -58.4627 ymin: -34.6625 xmax: -58.33514 ymax: -34.56935 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## barrios ## 1 CONSTITUCION - MONSERRAT - PUERTO MADERO - RETIRO - SAN NICOLAS - SAN TELMO ## 2 RECOLETA ## 3 BALVANERA - SAN CRISTOBAL ## 4 BARRACAS - BOCA - NUEVA POMPEYA - PARQUE PATRICIOS ## 5 ALMAGRO - BOEDO ## 6 CABALLITO ## perimetro area comunas geometry ## 1 35572.65 17802807 1 MULTIPOLYGON (((-58.3685405... ## 2 21246.61 6140873 2 MULTIPOLYGON (((-58.3952057... ## 3 10486.26 6385991 3 MULTIPOLYGON (((-58.4119188... ## 4 36277.44 21701236 4 MULTIPOLYGON (((-58.3552004... ## 5 12323.47 6660526 5 MULTIPOLYGON (((-58.4128700... ## 6 10990.96 6851029 6 MULTIPOLYGON (((-58.4306058... Podemos ver que el dataframe contiene 15 filas y 5 columnas. Una fila por comuna (es razonable!) y 5 columnas: “barrios”, “perímetro”, “area”, “comunas” y “geometry”. Nuestro vistazo mediante head() permite asumir que “barrios” informa los barrios que componen cada comuna, mientras que perímetro y área informan sobre las dimensiones del polígono cubierto por cada comuna. La columna “geometry” aparece en todos los dataframes de tipo espacial, y es la que contiene los datos con sus coordenadas geográficas. Y hablando de coordenadas, generar un mapa a partir de un dataframe espacial creado por sf es muy fácil con la ayuda de ggplot1 ggplot(comunas) + geom_sf() Si queremos agregar una leyenda al mapa que identifique cada comuna con su número, usamos: ggplot(comunas) + geom_sf(aes(fill = comunas)) Dentro de “aes()” usé el parámetro “fill” (relleno en inglés) para pedirle a ggplot que llene cada polígono con un color distinto de acuerdo al campo “comunas”. Aprovechando que tenemos un mapa, deberíamos clasificar las comunas entre las que pertenecen al norte y las que pertenecen al sur de la ciudad. No hay una línea divisoria oficial, pero la traza de la Avenida Rivadavia suele ser tomada como frontera: Rivadavia es la “divisoria simbólica del Norte y el Sur de la Ciudad, con sus diferencias de desarrollo” Por esas casualidades de la vida, tengo un archivo geográfico que contiene la línea que dibuja a avenida Rivadavia al atravesar la ciudad. Lo bajamos: rivadavia &lt;- st_read(&#39;https://bitsandbricks.github.io/data/avenida_rivadavia.geojson&#39;) ## Reading layer `OGRGeoJSON&#39; from data source `https://bitsandbricks.github.io/data/avenida_rivadavia.geojson&#39; using driver `GeoJSON&#39; ## Simple feature collection with 1 feature and 1 field ## geometry type: LINESTRING ## dimension: XY ## bbox: xmin: -58.53014 ymin: -34.63946 xmax: -58.37017 ymax: -34.60711 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs Y lo proyectamos sobre el mapa, como una capa adicional del gráfico de ggplot que definimos antes: ggplot(comunas) + geom_sf(aes(fill = comunas)) + geom_sf(data = rivadavia, color = &quot;red&quot;) La identificación por colores no hace fácil reconocer con rapidez que número corresponde a cada comuna; es un recurso que funciona mejor con menos categorías que nuestras 15. Podríamos arreglarlo, por ejemplo evitando la codificación por color, y dibujando una etiqueta con número dibujada sobre cada comuna. ¡Pero no en este momento! En aras de la sencillez, vamos a aguzar la vista y tomar nota de cuales comunas tienen gran parte de su territorio al sur de la Avenida Rivadavia. Según mi interpretación, son las comunas 1, 3, 4, 5, 7, 8 y 9. (Hay que admitir que la comuna 1 parece estar repartida en partes más o menos iguales, pero vamos a dejársela al sur en forma arbitraria para no complicar el ejercicio). 2.6 Agregando datos En este punto necesitamos una manera de “etiquetar” cada comuna con el punto cardinal que le toca “Norte” o “Sur”. La forma más rápida es crear una lista con los atributos, y agregarla a nuestro dataframe como una nueva columna. Podemos armar una sucesión de 15 “etiquetas” según el punto cardinal que le toca a cada comuna. El comando en R que “une” valores en conjunto se llama c() (viene de “combine”, “combinar”), y permite definir una lista de valores. Mejor dicho, un “vector” de valores; en el mundo de la programación, se usa la palabra vector cuando se combinan elementos del mismo tipo, y “lista” cuando se combina una variedad de clases: en el mismo conjunto números, textos, y otros tipos de objeto más complejos. Por ahora, no nos preocupemos por eso. nueva_columna &lt;- c(&quot;Sur&quot;, &quot;Norte&quot;, &quot;Sur&quot;, &quot;Sur&quot;, &quot;Sur&quot;, &quot;Norte&quot;, &quot;Sur&quot;, &quot;Sur&quot;, &quot;Sur&quot;, &quot;Norte&quot;, &quot;Norte&quot;, &quot;Norte&quot;, &quot;Norte&quot;, &quot;Norte&quot;, &quot;Norte&quot;) nueva_columna ## [1] &quot;Sur&quot; &quot;Norte&quot; &quot;Sur&quot; &quot;Sur&quot; &quot;Sur&quot; &quot;Norte&quot; &quot;Sur&quot; &quot;Sur&quot; ## [9] &quot;Sur&quot; &quot;Norte&quot; &quot;Norte&quot; &quot;Norte&quot; &quot;Norte&quot; &quot;Norte&quot; &quot;Norte&quot; Ya podemos agregar nuestra nueva columna usando una función que ya vimos, mutate(). En el dataframe, vamos a ponerle a nuestra nueva columna un nombre descriptivo, “ubicación” : comunas &lt;- mutate(comunas, ubicacion = nueva_columna) Verifiquemos el resultado: head(comunas) ## Simple feature collection with 6 features and 5 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -58.4627 ymin: -34.6625 xmax: -58.33514 ymax: -34.56935 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## barrios ## 1 CONSTITUCION - MONSERRAT - PUERTO MADERO - RETIRO - SAN NICOLAS - SAN TELMO ## 2 RECOLETA ## 3 BALVANERA - SAN CRISTOBAL ## 4 BARRACAS - BOCA - NUEVA POMPEYA - PARQUE PATRICIOS ## 5 ALMAGRO - BOEDO ## 6 CABALLITO ## perimetro area comunas ubicacion geometry ## 1 35572.65 17802807 1 Sur MULTIPOLYGON (((-58.3685405... ## 2 21246.61 6140873 2 Norte MULTIPOLYGON (((-58.3952057... ## 3 10486.26 6385991 3 Sur MULTIPOLYGON (((-58.4119188... ## 4 36277.44 21701236 4 Sur MULTIPOLYGON (((-58.3552004... ## 5 12323.47 6660526 5 Sur MULTIPOLYGON (((-58.4128700... ## 6 10990.96 6851029 6 Norte MULTIPOLYGON (((-58.4306058... Y en el mapa: ggplot(comunas) + geom_sf(aes(fill = ubicacion)) + geom_sf(data = rivadavia, color = &quot;red&quot;) Todo en orden. Ahora hagamos lo mismo con el dataframe de mortalidad, aprovechando que lista las comunas en el mismo orden (del 1 al 15) y por lo tanto podemos “pegarle” el mismo vector de etiquetas con ubicación que ya preparamos. mortalidad &lt;- mutate(mortalidad, ubicación = nueva_columna) head(mortalidad) ## Comuna Tasa2016 ubicación ## 1 1 9.5 Sur ## 2 2 3.6 Norte ## 3 3 8.0 Sur ## 4 4 11.9 Sur ## 5 5 8.5 Sur ## 6 6 2.4 Norte 2.7 El veredicto final Habrán notado que llegar hasta aquí tomó una buena cantidad de operaciones. En contraste, lo que estamos a punto de hacer -responder la pregunta inicial- va a ser mucho más breve. Esa vendría a ser la lección central de éste capítulo: la mayor parte del tiempo empleado en la labor de la ciencia de datos se insume en la poco glamorosa tarea de recopilar, limpiar y combinar los registros necesarios para el análisis. Como consuelo, podemos pensar en que el esfuerzo necesario para llegar a este punto nos ha dado un conocimiento de los datos (su estructura, sus limitaciones, su potencial) que no teníamos antes. Aprovechemos entonces nuestra data limpia y ordenada, para producir un mapa que señale con color el nivel de mortalidad. Armamos un ggplot con una capa que muestra las comunas, cuyo color interior (“fill”) depende del valor de la mortalidad. Le sumamos una capa con la traza de la Avenida Rivadavia, nuestra referencia de posición, y por último definimos la paleta de colores a usar en el fill, eligiendo una llamada “Spectral”, que va del azul al rojo y es muy usada cuando se quiere resaltar la divergencia de una variable. ggplot(comunas) + geom_sf(aes(fill = mortalidad$Tasa2016)) + geom_sf(data = rivadavia, color = &quot;red&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) Para una comparación visual más precisa entre los valores de cada comuna, le pedimos a ggplot un gráfico de barras, con la capa geom_col(). En las variables estéticas, definimos que la posición de las barras en el eje de las x estará dada por el número de cada comuna, la altura de las barras (eje y) será dada por su tasa de mortalidad, y su color de relleno (fill) dependerá de su ubicación geográfica. ggplot(mortalidad) + geom_col(aes(x = Comuna, y = Tasa2016, fill = ubicación)) + labs(title = &quot;Mortalidad infantil en la Ciudad Autónoma de Buenos Aires&quot;, subtitle = &quot;Año 2016&quot;, y = &quot;tasa&quot;) Por último, usamos a R de calculadora. Separamos las comunas en dos dataframes distintos según su ubicación, con el comando filter()… comunas_al_sur &lt;- filter(mortalidad, ubicación == &quot;Sur&quot;) comunas_al_norte &lt;- filter(mortalidad, ubicación == &quot;Norte&quot;) … y calculamos la diferencia entre el promedio de mortalidad de unas y otras. mean(comunas_al_sur$Tasa2016) / mean(comunas_al_norte$Tasa2016) ## [1] 2.044788 2.8 ¿Cuál es la diferencia en mortalidad infantil entre el sur y el norte de la Ciudad Autónoma de Buenos Aires? En base a lo que descubrimos, vamos a responder en forma sucinta. En el año 2016, la tasa de mortalidad infantil en todo los barrios del sur es más alta que en cualquier de los del norte. Para los nacidos en 2016 de padres que viven en el sur de la ciudad, la posibilidad de morir antes del primer año es, en promedio, el doble que la de aquellos con padres que residen al norte. Por supuesto, con esto no puede darse por cerrado el tema; hay muchas facetas que deberíamos analizar para comenzar a entender un fenómeno social de tal complejidad. Por ejemplo, ¿Cómo es la evolución en el tiempo de la brecha norte/sur - se mantiene igual, decrece, aumenta? ¿Qué otros factores están correlacionados con la disparidad, más allá del geográfico? En los siguientes capítulos practicaremos varias técnicas que nos permitirán profundizar nuestros análisis, en la nunca finalizada misión de entender un poco más. Al momento de redactar este capítulo, la función geom_sf esta disponible sólo en la versión de desarrollo de ggplot, que puede ser instalada con devtools::install_github(&quot;hadley/ggplot2&quot;)↩ "],
["poniendo-los-datos-en-forma.html", "Capítulo 3 Poniendo los datos en forma 3.1 Primeros pasos al examinar un conjunto de datos nuevo 3.2 Transformando los datos", " Capítulo 3 Poniendo los datos en forma Cómo ya hemos mencionado, es normal que la mayor parte del tiempo dedicado a un proyecto de análisis se nos vaya en la limpieza y orden de los datos disponibles. Aún cuando nuestros datos provengan de fuentes oficiales (un gobierno nacional, el Banco Mundial, etc) en muy rara ocasión podremos usarlos para nuestros fines sin antes procesarlos. Y aún si los datos llegaran en perfectas condiciones, no tenemos forma de saberlo hasta haber realizado una exploración para verificarlo. Ésta inevitable etapa de preparación es llamada data wrangling en inglés, algo así como el proceso de “domar los datos”. El término hace referencia, en clave de humor, al esfuerzo que la puesta en orden cuando los datos son cuantiosos, de muchas fuentes distintas, o en particular desprolijos. Para que la experiencia sea lo menos tediosa posible, y podamos pasar rápido al momento de extraer conocimiento, vamos a practicar algunas técnicas muy útiles. 3.1 Primeros pasos al examinar un conjunto de datos nuevo Vamos a practicar usando los registros del Sistema Único de Atención Ciudadana (SUACI) de la Ciudad Autónoma de Buenos Aires. El SUACI es el repositorio donde se integran las solicitudes y reclamos que los ciudadanos presentan a la ciudad por distintos canales: en persona, por teléfono o usando la aplicación BA 147. Vamos a trabajar con una versión de los datos que ha sido simplificada para hacer más ameno el trabajo con ella. Quién quiera acceder a los datos en su esplendor de complejidad original, puede encontrarlos en el portal de datos abiertos de la ciudad: https://data.buenosaires.gob.ar/ Comenzamos por acceder al archivo con los registros para cargarlo en R como un dataframe. Tendremos que ejercitar un poco la paciencia porque es un archivo de varios megas, que podría tardar unos minutos en ser descargado. atencion_ciudadano &lt;- read.csv(&#39;http://bitsandbricks.github.io/data/gcba_suaci_barrios.csv&#39;) Lo primero que deberíamos hacer con un dataframe que no conocemos es usar la función str(), que nos indica su estructura (por structure en inglés): str(atencion_ciudadano) ## &#39;data.frame&#39;: 57432 obs. of 5 variables: ## $ PERIODO : int 201301 201301 201301 201301 201301 201301 201301 201301 201301 201301 ... ## $ RUBRO : Factor w/ 347 levels &quot;&quot;,&quot;ACCESOS&quot;,&quot;ACERAS&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ TIPO_PRESTACION: Factor w/ 6 levels &quot;&quot;,&quot;DENUNCIA&quot;,..: 4 4 4 4 4 4 4 4 4 4 ... ## $ BARRIO : Factor w/ 52 levels &quot;&quot;,&quot; &quot;,&quot;AGRONOMIA&quot;,..: 3 4 5 6 7 8 9 10 11 12 ... ## $ total : int 6 172 92 45 79 10 38 109 20 45 ... Lo primero que se nos informa es que nuestro objeto de análisis es un dataframe (“data.frame” ). Eso ya lo sabíamos, pero como str() puede usarse con cualquier clase de objeto en R, en un contexto distinto podría ser información nueva. A continuación aparecen las dimensiones del dataframe: 164.33 observaciones (filas) con 5 variables (columnas). Los nombres de las columnas son PERIODO, RUBRO, TIPO_PRESTACION, BARRIO y total. Con eso ya podemos inferir que cada observación en el dataframe contiene la cantidad total de solicitudes según concepto, rubro y tipo de prestación (aunque no sepamos bien de que se tratan esas variables), en un período dado y en cada barrio. Con str() también obtenemos el tipo de datos representados pro cada variable, y un ejemplo de los valores contenidos en las primeras filas. PERIODO y total son variables de tipo “int”, es decir, números enteros o integers en inglés. El resto de las variables son de tipo “Factor”; en R las variables categóricas reciben el nombre de factores. ¿Y cómo sabe R que RUBRO o BARRIO son categorías? La culpable es la función read.csv() que usamos al principio. Si no se le aclara lo contrario, read.csv() interpreta como factores a todas las columnas que contienen texto. Para avisarle que no lo haga, hay que usar el parámetro stringsAsFactors, así: misdatos &lt;- read.csv('archivo_con_mis_datos', stringsAsFactors = FALSE). En general es buena idea evitar que los campos de texto se asuman como factores, pero en éste caso está bien: todas las columnas de texto, en efecto, contienen variables categóricas. (Ante la duda, una variable es categórica cuando es razonable considerar que se elige entre un conjunto finito de variables posibles; por ejemplo, los barrios de Buenos Aires son un conjunto finito y predeterminado). La siguiente función a utilizar cuando estamos conociendo el contenido de un set de datos es summary(), que nos dará un resumen en forma de estadísticas descriptivas para las variables numéricas (cuartiles y mediana) y un vistazo a las categorías más representadas par los factores. summary(atencion_ciudadano) ## PERIODO RUBRO TIPO_PRESTACION ## Min. :201301 SANEAMIENTO URBANO : 4589 : 1 ## 1st Qu.:201309 TRANSPORTE Y TRANSITO: 4580 DENUNCIA :21606 ## Median :201404 ARBOLADO : 3122 QUEJA : 3914 ## Mean :201401 ALUMBRADO : 2918 RECLAMO :21038 ## 3rd Qu.:201503 PAVIMENTO : 2411 SOLICITUD: 9662 ## Max. :201512 ESPACIO PUBLICO : 1918 TRAMITE : 1211 ## (Other) :37894 ## BARRIO total ## PALERMO : 2154 Min. : 1.00 ## BALVANERA : 1961 1st Qu.: 1.00 ## FLORES : 1959 Median : 4.00 ## CABALLITO : 1872 Mean : 34.85 ## SAN NICOLAS: 1748 3rd Qu.: 16.00 ## RECOLETA : 1729 Max. :19221.00 ## (Other) :46009 Las categorías posibles para un factor son llamadas “niveles” (levels). Para ver todos los niveles del factor BARRIO, es decir todos los barrios representados en la columna con la variable BARRIO, podemos usar la función levels() levels(atencion_ciudadano$BARRIO) ## [1] &quot;&quot; &quot; &quot; &quot;AGRONOMIA&quot; ## [4] &quot;ALMAGRO&quot; &quot;BALVANERA&quot; &quot;BARRACAS&quot; ## [7] &quot;BELGRANO&quot; &quot;BOCA&quot; &quot;BOEDO&quot; ## [10] &quot;CABALLITO&quot; &quot;CHACARITA&quot; &quot;COGHLAN&quot; ## [13] &quot;COLEGIALES&quot; &quot;CONSTITUCION&quot; &quot;ERRORNOHAYRESULTA&quot; ## [16] &quot;ERRORNOHAYRESULTADOS&quot; &quot;FLORES&quot; &quot;FLORESTA&quot; ## [19] &quot;LINIERS&quot; &quot;MATADEROS&quot; &quot;MONSERRAT&quot; ## [22] &quot;MONTE CASTRO&quot; &quot;NUEVA POMPEYA&quot; &quot;NUÑEZ&quot; ## [25] &quot;PALERMO&quot; &quot;PARQUE AVELLANEDA&quot; &quot;PARQUE CHACABUCO&quot; ## [28] &quot;PARQUE CHAS&quot; &quot;PARQUE PATRICIOS&quot; &quot;PATERNAL&quot; ## [31] &quot;PUERTO MADERO&quot; &quot;RECOLETA&quot; &quot;RETIRO&quot; ## [34] &quot;SAAVEDRA&quot; &quot;SAN CRISTOBAL&quot; &quot;SAN NICOLAS&quot; ## [37] &quot;SAN TELMO&quot; &quot;VELEZ SARSFIELD&quot; &quot;VERSALLES&quot; ## [40] &quot;VILLA CRESPO&quot; &quot;VILLA DEL PARQUE&quot; &quot;VILLA DEVOTO&quot; ## [43] &quot;VILLA GRAL. MITRE&quot; &quot;VILLA LUGANO&quot; &quot;VILLA LURO&quot; ## [46] &quot;VILLA ORTUZAR&quot; &quot;VILLA PUEYRREDON&quot; &quot;VILLA REAL&quot; ## [49] &quot;VILLA RIACHUELO&quot; &quot;VILLA SANTA RITA&quot; &quot;VILLA SOLDATI&quot; ## [52] &quot;VILLA URQUIZA&quot; Para acceder en forma rápida al contenido de la columna BARRIO, hemos utilizado por primera vez un “truco” muy práctico. Para obtener el contenido de cualquier columna en particular, basta con el nombre del dataframe seguido del símbolo $ y el nombre de la columna a extraer: atencion_ciudadano$BARRIO, o atencion_ciudadano$total, etc. 3.2 Transformando los datos Habiendo revisado el contenido de un dataframe, comenzamos a hacernos idea de los ajustes que necesita para que los datos tomen el formato que necesitamos. Estos ajustes pueden ser correcciones (por ejemplo, de errores de tipeo cuando se cargaron los datos), la creación de nuevas variables derivadas de las existentes, o un reordenamiento de los datos para simplificar nuestro trabajo. Para hacer todo esto, y mucho más, vamos a aprender funciones que representan cinco verbos básicos para la transformación de datos: select(): seleccionar -elegir- columnas por su nombre filter(): filtrar, es decir quedarse sólo con las filas que cumplan cierta condición arrange(): ordenar las filas de acuerdo a su contenido o algún otro índice mutate(): mutar -cambiar- un dataframe, modificando el contenido de sus columnas o creando columnas (es decir, variables) nuevas summarise(): producir sumarios -un valor extraído de muchos, por ejemplo el promedio- con el contenido de las columnas Estas funciones tienen una sintaxis, una forma de escribirse, uniforme. El primer argumento que toman siempre es un dataframe; los siguientes indican qué hacer con los datos. El resultado siempre es un nuevo dataframe. Las funciones son parte de (dplyr)[http://dplyr.tidyverse.org/], uno de los paquetes de funciones de la familia (Tidyverse)[https://www.tidyverse.org/]. Si no lo hicimos aún en la sesión en la que estamos trabajando, cargamos tidyverse. library(tidyverse) 3.2.1 Seleccionar columnas con select() Muchas veces tendremos que lidiar con datasets con decenas de variables. Alguna que otra vez, con centenas. En esos casos el primer problema es librarnos de semejante cantidad de columnas, reteniendo sólo aquellas en las que estamos interesados. Para un dataset como el de reclamos de los ciudadanos, que tiene pocas columnas, select() no es tan importante. Aún así, podemos usar select() con fines demostrativos. Sabemos que el dataset tiene 5 columnas: names(atencion_ciudadano) ## [1] &quot;PERIODO&quot; &quot;RUBRO&quot; &quot;TIPO_PRESTACION&quot; &quot;BARRIO&quot; ## [5] &quot;total&quot; Si quisiéramos sólo las que contienen el período y el total, las seleccionamos por nombre, a continuación del nombre del dataframe: seleccion &lt;- select(atencion_ciudadano, PERIODO, total) head(seleccion) ## PERIODO total ## 1 201301 6 ## 2 201301 172 ## 3 201301 92 ## 4 201301 45 ## 5 201301 79 ## 6 201301 10 También podemos seleccionar por contigüidad, por ejemplo “todas las columnas que van de RUBRO a BARRIO”: seleccion &lt;- select(atencion_ciudadano, RUBRO:BARRIO) head(seleccion) ## RUBRO TIPO_PRESTACION BARRIO ## 1 ACERAS RECLAMO AGRONOMIA ## 2 ACERAS RECLAMO ALMAGRO ## 3 ACERAS RECLAMO BALVANERA ## 4 ACERAS RECLAMO BARRACAS ## 5 ACERAS RECLAMO BELGRANO ## 6 ACERAS RECLAMO BOCA Y podemos seleccionar por omisión. Si nos interesara todo el contenido del dataset menos la variable RUBRO, usaríamos seleccion &lt;- select(atencion_ciudadano, -RUBRO) head(seleccion) ## PERIODO TIPO_PRESTACION BARRIO total ## 1 201301 RECLAMO AGRONOMIA 6 ## 2 201301 RECLAMO ALMAGRO 172 ## 3 201301 RECLAMO BALVANERA 92 ## 4 201301 RECLAMO BARRACAS 45 ## 5 201301 RECLAMO BELGRANO 79 ## 6 201301 RECLAMO BOCA 10 Al igual que con las selección por inclusión, podemos seleccionar por omisión de un rango de columnas contiguas (escritas entre paréntesis), o de varias columnas nombradas: seleccion &lt;- select(atencion_ciudadano, -(TIPO_PRESTACION:total)) head(seleccion) ## PERIODO RUBRO ## 1 201301 ACERAS ## 2 201301 ACERAS ## 3 201301 ACERAS ## 4 201301 ACERAS ## 5 201301 ACERAS ## 6 201301 ACERAS seleccion &lt;- select(atencion_ciudadano, -RUBRO, -BARRIO) head(seleccion) ## PERIODO TIPO_PRESTACION total ## 1 201301 RECLAMO 6 ## 2 201301 RECLAMO 172 ## 3 201301 RECLAMO 92 ## 4 201301 RECLAMO 45 ## 5 201301 RECLAMO 79 ## 6 201301 RECLAMO 10 3.2.2 Filtrar filas con filter() Una de las tareas más frecuentes en el análisis de datos es la de identificar observaciones que cumplen con determinada condición. filter() permite extraer subconjuntos del total en base a sus variables. Por ejemplo, para seleccionar registros que correspondan a Retiro, ocurridos en el primer mes de 2014 (período 201401): seleccion &lt;- filter(atencion_ciudadano, BARRIO == &quot;RETIRO&quot;, PERIODO == 201401) head(seleccion) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201401 ACERAS RECLAMO RETIRO 10 ## 2 201401 ALUMBRADO RECLAMO RETIRO 34 ## 3 201401 ALUMBRADO SOLICITUD RETIRO 2 ## 4 201401 ARBOLADO RECLAMO RETIRO 10 ## 5 201401 ARBOLADO SOLICITUD RETIRO 3 ## 6 201401 ATENCION AL PUBLICO QUEJA RETIRO 3 3.2.2.1 Comparaciones Aquí hemos usado un recurso nuevo, la comparación. R provee una serie de símbolos que permite comparar valores entre sí: * `==` igual a * `!=` no igual a * `&gt;` mayor a * `&gt;=` mayor o igual a * `&lt;` menor a * `&lt;=` menor o igual a Atención especial merece el símbolo que compara igualdad, ==. Un error muy común es escribir BARRIO = &quot;RETIRO&quot;, (un sólo símbolo =) que le indica a R que guarde el valor “RETIRO” dentro de la variable BARRIO, en lugar de verificar si son iguales. Para ésto último, lo correcto es BARRIO == &quot;RETIRO&quot;, tal como lo usamos en el ejemplo de filter(). También hay que tener en cuenta el uso de comillas. Para que R no se confunda, cuando queramos usar valores de texto (de tipo character) los rodeamos con comillas para que quede claro que no nos referimos a una variable con ese nombre, si la hubiera, sino en forma literal a esa palabra o secuencia de texto. En el caso de los números, no hace falta el uso de comillas, ya que en R ningún nombre de variable puede comenzar con o estar compuesta sólo por números. Filtrando los registros de períodos para los cuales se registran más de 100 incidentes: seleccion &lt;- filter(atencion_ciudadano, total &gt; 100) head(seleccion) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201301 ACERAS RECLAMO ALMAGRO 172 ## 2 201301 ACERAS RECLAMO CABALLITO 109 ## 3 201301 ACERAS RECLAMO FLORES 111 ## 4 201301 ACERAS RECLAMO PALERMO 113 ## 5 201301 ALUMBRADO RECLAMO ALMAGRO 130 ## 6 201301 ALUMBRADO RECLAMO BARRACAS 118 3.2.2.2 Operadores lógicos Cuando le pasamos múltiples condiciones a filter(), la función devuelve las filas que cumplen con todas. Por ejemplo, con seleccion &lt;- filter(atencion_ciudadano, PERIODO == 201508, RUBRO == &quot;SALUD&quot;) head(seleccion) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201508 SALUD QUEJA BARRACAS 1 ## 2 201508 SALUD QUEJA CABALLITO 1 ## 3 201508 SALUD QUEJA COGHLAN 1 ## 4 201508 SALUD QUEJA RECOLETA 1 obtenemos todos los registros cuyo rubro es “SALUD”, y cuyo período es 20108, agosto de 2015. Siguiendo el mismo formato, si intentamos seleccion &lt;- filter(atencion_ciudadano, BARRIO == &quot;RETIRO&quot;, BARRIO == &quot;PALERMO&quot;) head(seleccion) ## [1] PERIODO RUBRO TIPO_PRESTACION BARRIO ## [5] total ## &lt;0 rows&gt; (or 0-length row.names) obtenemos un conjunto vacío. ¿Por qué? Es debido a que ninguna observación cumple con todas las condiciones; el ningún registro el barrio es Retiro y es Palermo. ¡Suena razonable!. Para obtener registros ocurrido en Retiro ó en Palermo, usamos el operador lógico | que significa… “ó”. seleccion &lt;- filter(atencion_ciudadano, BARRIO == &quot;RETIRO&quot; | BARRIO == &quot;PALERMO&quot;) head(seleccion) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201301 ACERAS RECLAMO PALERMO 113 ## 2 201301 ACERAS RECLAMO RETIRO 15 ## 3 201301 ACERAS SOLICITUD PALERMO 2 ## 4 201301 ACTOS DE CORRUPCION DENUNCIA PALERMO 4 ## 5 201301 ALUMBRADO RECLAMO PALERMO 74 ## 6 201301 ALUMBRADO RECLAMO RETIRO 15 Se trata de la lógica de conjuntos, o lógica booleana, que con un poco de suerte recordamos de nuestra época de escolares. Los símbolos importantes son &amp;, |, y !: “y”, “’ó”, y la negación que invierte preposiciones: * `a &amp; b` a y b * `a | b` a ó b * `a &amp; !b` a, y no b * `!a &amp; b` no a, y b * `!(a &amp; b)` no (a y b) Hemos visto ejemplos de a &amp; b (PERIODO == 201508, RUBRO == &quot;SALUD&quot;, que filter toma como un &amp;) y de a | b (BARRIO == &quot;RETIRO&quot; | BARRIO == &quot;PALERMO&quot;) Un ejemplo de a &amp; !b, filas en las que el tipo de prestación sea “TRAMITE”, y en las que el rubro no sea “REGISTRO CIVIL”: filter(atencion_ciudadano, TIPO_PRESTACION == &quot;TRAMITE&quot; &amp; !(RUBRO == &quot;REGISTRO CIVIL&quot;)) Y como ejemplo de !(a &amp; b), todas las filas excepto las de tipo “DENUNCIA”, y rubro “SEGURIDAD E HIGIENE”: seleccion &lt;- filter(atencion_ciudadano, !(TIPO_PRESTACION == &quot;DENUNCIA&quot; &amp; RUBRO == &quot;SEGURIDAD E HIGIENE&quot;)) head(seleccion) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201301 ACERAS RECLAMO AGRONOMIA 6 ## 2 201301 ACERAS RECLAMO ALMAGRO 172 ## 3 201301 ACERAS RECLAMO BALVANERA 92 ## 4 201301 ACERAS RECLAMO BARRACAS 45 ## 5 201301 ACERAS RECLAMO BELGRANO 79 ## 6 201301 ACERAS RECLAMO BOCA 10 3.2.3 Ordenar filas con arrange() La función arrange() cambia el orden en el que aparecen las filas de un dataframe. Como primer parámetro toma un dataframe, al igual que el resto de los verbos de transformación que estamos aprendiendo. A continuación, espera un set de columnas para definir el orden. Por ejemplo, para ordenar por total de registros: ordenado &lt;- arrange(atencion_ciudadano, total) head(ordenado) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201301 ACERAS RECLAMO PUERTO MADERO 1 ## 2 201301 ACERAS SOLICITUD BARRACAS 1 ## 3 201301 ACERAS SOLICITUD BOCA 1 ## 4 201301 ACERAS SOLICITUD BOEDO 1 ## 5 201301 ACERAS SOLICITUD COGHLAN 1 ## 6 201301 ACERAS SOLICITUD CONSTITUCION 1 Si agregamos más columnas, se usan en orden para “desempatar”. Por ejemplo, si queremos que las filas con el mismo valor en total aparezcan en el orden alfabético del barrio que les corresponde, sólo necesitamos agregar esa columna: ordenado &lt;- arrange(atencion_ciudadano, total, BARRIO) head(ordenado) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201409 1 ## 2 201301 ALUMBRADO SOLICITUD AGRONOMIA 1 ## 3 201301 ATENCION SOCIAL RECLAMO AGRONOMIA 1 ## 4 201301 ESPACIO PUBLICO RECLAMO AGRONOMIA 1 ## 5 201301 QUEJA QUEJA AGRONOMIA 1 ## 6 201301 RECUPERADORES RECLAMO AGRONOMIA 1 Si no se aclara lo contrario, el orden siempre es ascendente (de menor a mayor). Si quisiéramos orden de mayor a menor, usamos desc(): ordenado &lt;- arrange(atencion_ciudadano, desc(total)) head(ordenado) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201502 REGISTRO CIVIL TRAMITE MONSERRAT 19221 ## 2 201403 REGISTRO CIVIL TRAMITE SAN NICOLAS 19209 ## 3 201402 REGISTRO CIVIL TRAMITE SAN NICOLAS 17032 ## 4 201504 REGISTRO CIVIL TRAMITE MONSERRAT 16746 ## 5 201503 REGISTRO CIVIL TRAMITE MONSERRAT 16730 ## 6 201506 REGISTRO CIVIL TRAMITE MONSERRAT 14674 3.2.3.1 Valores faltantes En el último ejemplo, aparecen varias filas cuyo valor para la columna BARRIO es NA. R representa los valores ausentes, desconocidos, con NA (“no disponible”, del inglés Not Available). Hay que tener cuidado con los valores NA, porque la mayoría de las comparaciones y operaciones lógicas que los involucran resultan indefinidas. En la práctica: ¿Es 10 mayor a un valor desconocido? 10 &gt; NA ## [1] NA R no sabe. (Nadie lo sabe, para ser justos) ¿A cuanto asciende la suma de 10 más un valor desconocido? NA + 10 ## [1] NA Y en particular… ¿es un valor desconocido igual a otro valor desconocido? NA == NA ## [1] NA Por supuesto, la respuesta es desconocida también. La insistencia de R en no definir operaciones que involucran NA’s podría parecer irritante a primera vista, pero en realidad nos hace un favor. Al evitar extraer conclusiones cuando trata con datos faltantes, nos evita caer en errores garrafales en los casos en que analizamos y comparamos datos incompletos. Además, podemos preguntar a R si un valor es desconocido, y allí si contesta con seguridad. La función requerida es is.na(). desconocido &lt;- NA is.na(desconocido) ## [1] TRUE Algo más a tener en cuenta con los valores desconocidos es cómo son interpretados cuando usamos funciones de transformación de datos. Por ejemplo, filter() ignora las filas que contienen NA’s en la variable que usa para filtrar. arrange() muestra las filas con NA’s en el campo por el que ordena, pero todas al final. 3.2.4 Agregar nuevas variables con mutate() Recurrimos a la función mutate() cuando queremos agregarle columnas adicionales a nuestro dataframe, en general en base a los valores de las columnas ya existentes. Vamos a ilustrarlo con un ejemplo sencillo. Imaginemos que tenemos el siguiente dataset: circulos &lt;- data.frame(nombre = c(&quot;Círculo 1&quot;, &quot;Círculo 2&quot;, &quot;Círculo 3&quot;), tamaño = c(&quot;Pequeño&quot;, &quot;Mediano&quot;, &quot;Grande&quot;), radio = c(1, 3, 5)) circulos ## nombre tamaño radio ## 1 Círculo 1 Pequeño 1 ## 2 Círculo 2 Mediano 3 ## 3 Círculo 3 Grande 5 Podemos agregar una columna con el área de cada círculo con mutate(): mutate(circulos, area = 3.1416 * radio^2) ## nombre tamaño radio area ## 1 Círculo 1 Pequeño 1 3.1416 ## 2 Círculo 2 Mediano 3 28.2744 ## 3 Círculo 3 Grande 5 78.5400 Usando mutate(), definimos la columna “area”, indicando que su contenido será el valor de la columna “radio” en cada registro puesto en la fórmula del área de un círculo. Los operadores aritméticos (+, -, *, /, ^) son con frecuencia útiles para usar en conjunto con mutate(). Volvamos ahora a nuestro dataframe con datos de reclamos. Supongamos que nos interesa agregar columnas con el mes y el año de cada registro. La columna período, con valores del tipo “201301”, contiene la información necesaria para derivar estas dos nuevas variables. Para separar la parte del año de la parte del mes, la función substr(), que extrae porciones de una variable de texto, nos va a dar una mano. La usamos así: el primer parámetro es una secuencia de caracteres, y los dos siguientes indican donde queremos que empiece y termine la porción a extraer. atencion_ciudadano &lt;- mutate(atencion_ciudadano, AÑO = substr(PERIODO, 1, 4), MES = substr(PERIODO, 5, 6)) head(atencion_ciudadano) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total AÑO MES ## 1 201301 ACERAS RECLAMO AGRONOMIA 6 2013 01 ## 2 201301 ACERAS RECLAMO ALMAGRO 172 2013 01 ## 3 201301 ACERAS RECLAMO BALVANERA 92 2013 01 ## 4 201301 ACERAS RECLAMO BARRACAS 45 2013 01 ## 5 201301 ACERAS RECLAMO BELGRANO 79 2013 01 ## 6 201301 ACERAS RECLAMO BOCA 10 2013 01 3.2.5 Extraer sumarios con summarise() Llegamos al último de los verbos fundamentales para transformar datos. summarise() (por “resumir” en inglés) toma un dataframe completo y lo resume un una sola fila, de acuerdo a la operación que indiquemos. Por ejemplo, el promedio de la columna “total”: summarise(atencion_ciudadano, promedio = mean(total)) ## promedio ## 1 34.84721 Por si sola, summarise() no es de mucha ayuda. La gracia está en combinarla con group_by(), que cambia la unidad de análisis del dataframe completo a grupos individuales. Usar summarise() sobre un dataframe al que antes agrupamos con group_by resulta en resúmenes “por grupo”. agrupado &lt;- group_by(atencion_ciudadano, AÑO) summarise(agrupado, promedio_totales = mean(total)) ## # A tibble: 3 x 2 ## AÑO promedio_totales ## &lt;chr&gt; &lt;dbl&gt; ## 1 2013 29.5 ## 2 2014 30.2 ## 3 2015 45.4 Podemos agrupar por múltiples columnas, generando más subgrupos; por ejemplo, promedios por por año y mes… agrupado &lt;- group_by(atencion_ciudadano, AÑO, MES) sumario &lt;- summarise(agrupado, promedio = mean(total)) head(sumario) ## # A tibble: 6 x 3 ## # Groups: AÑO [1] ## AÑO MES promedio ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2013 01 25.1 ## 2 2013 02 26.1 ## 3 2013 03 26.9 ## 4 2013 04 29.5 ## 5 2013 05 28.0 ## 6 2013 06 28.9 … o por año, mes y barrio: agrupado &lt;- group_by(atencion_ciudadano, AÑO, MES, BARRIO) sumario &lt;- summarise(agrupado, promedio = mean(total)) head(sumario) ## # A tibble: 6 x 4 ## # Groups: AÑO, MES [1] ## AÑO MES BARRIO promedio ## &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 2013 01 AGRONOMIA 14.6 ## 2 2013 01 ALMAGRO 29.5 ## 3 2013 01 BALVANERA 23.6 ## 4 2013 01 BARRACAS 19.4 ## 5 2013 01 BELGRANO 24.4 ## 6 2013 01 BOCA 9.97 3.2.6 !BONUS! El operador “pipe”: %&gt;% Antes de terminar, vamos a presentar una herramienta más: el operador pipe (pronúnciese “paip”, es el término en inglés que significa “tubo”). El pipe es un operador: un símbolo que relaciona dos entidades. Dicho en forma más simple, el pipe de R, cuyo símbolo es %&gt;% está en familia con otros operadores más convencionales, como +, - o /. Y al igual que los otros operadores, entrega un resultado en base a los operandos que recibe. Ahora bien… ¿Para qué sirve? En resumidas cuentas, hace que el código necesario para realizar una serie de operaciones de transformación de datos sea mucho más simple de escribir y de interpretar. Por ejemplo, si quisiéramos obtener el top 5 de los barrios que más reclamos y denuncias de los ciudadanos han registrado durante 2015, la forma de lograrlo en base a lo que ya sabemos sería así: 1. Filtramos los datos para aislar los registros del 2014; 2. agrupamos por Barrio; 3. hacemos un sumario, creando una variable resumen que contiene la suma de los registros para cada barrio; 4. los ordenamos en forma descendiente, 5. mostramos sólo los primeros 5 (esto se puede hacer con la función `head()`, aclarando cuantas filas queremos ver) En código: solo2014 &lt;- filter(atencion_ciudadano, AÑO == 2014) solo2014_agrupado_barrio &lt;- group_by(solo2014, BARRIO) total_por_barrio_2014 &lt;- summarise(solo2014_agrupado_barrio, total = sum(total)) total_por_barrio_2014_ordenado &lt;- arrange(total_por_barrio_2014, desc(total)) head(total_por_barrio_2014_ordenado, 5) ## # A tibble: 5 x 2 ## BARRIO total ## &lt;fct&gt; &lt;int&gt; ## 1 SAN NICOLAS 180956 ## 2 PALERMO 22569 ## 3 CABALLITO 19706 ## 4 FLORES 15919 ## 5 VILLA DEVOTO 15720 ¡Funciona! Pero… el problema es que hemos generado un puñado de variables (“solo2014”, “solo2014_agrupado_barrio”, etc) que, es probable, no volveremos a usar. Además de ser inútiles una vez obtenido el resultado buscado, estas variables intermedias requieren que las nombremos. Decidir el nombre de estas variables que no nos importan toma tiempo (sobre todo cuando producimos muchas), y nos distrae de lo importante, que es el análisis. El pipe, %&gt;%, permite encadenar operaciones, conectando el resultado de una como el dato de entrada de la siguiente. La misma secuencia que realizamos antes puede resolverse con pipes, quedando así: atencion_ciudadano %&gt;% filter(AÑO == 2014) %&gt;% group_by(BARRIO) %&gt;% summarise(total = sum(total)) %&gt;% arrange(desc(total)) %&gt;% head(5) ## # A tibble: 5 x 2 ## BARRIO total ## &lt;fct&gt; &lt;int&gt; ## 1 SAN NICOLAS 180956 ## 2 PALERMO 22569 ## 3 CABALLITO 19706 ## 4 FLORES 15919 ## 5 VILLA DEVOTO 15720 Una manera de pronunciar %&gt;% cuando leemos código es “y luego…”. Algo así como “tomamos el dataframe”atencion_ciudadano&quot; y luego filtramos los registros del año 2014, y luego agrupamos por barrio, y luego calculamos el total de registros para cada grupo, y luego los ordenamos en forma descendente por total, y luego vemos los cinco primeros“. El uso de pipes permite concentrarse en las operaciones de transformación, y no en lo que está siendo transformado en cada paso. Esto hace al código mucho más sencillo de leer e interpretar. En el ejemplo con pipe, sólo tuvimos que nombrar un dataframe con el cual trabajar un única vez, al principio. Detrás de escena, x %&gt;% f(y) se transforma en f(x, y). Por eso, filter(atencion_ciudadano, AÑO == 2014) es equivalente a atencion_ciudadano %&gt;% filter(AÑO == 2014) Trabajar con pipes es una de las ventajas que hacen de R un lenguaje muy expresivo y cómodo para manipular datos, y a partir de aquí lo usaremos de forma habitual. Con esto cerramos la sección de transformación de datos. Las técnicas para examinar un dataframe, como sumamry() nos permiten entender de forma rápida con que clase de variables vamos a trabajar. Los cinco verbos de manipulación que aprendimos, usados en conjunto, brindan una enorme capacidad para adaptar el formato de los datos a nuestras necesidades. Y el operador pipe nos ayuda a escribir nuestro código de forma sucinta y fácil de interpretar. A medida que vayamos progresando en nuestra familiaridad con las funciones -y agregando técnicas nuevas- vamos a ser capaces de procesar grandes cantidades de datos con soltura. Y obtener en pocos minutos lo que de otra forma, sin herramientas computacionales, tardaría días o sería inviable por lo tedioso. "],
["visualizacion.html", "Capítulo 4 Visualización", " Capítulo 4 Visualización "],
["modelado-estadistico.html", "Capítulo 5 Modelado estadístico", " Capítulo 5 Modelado estadístico "],
["mapas.html", "Capítulo 6 Mapas", " Capítulo 6 Mapas "]
]
