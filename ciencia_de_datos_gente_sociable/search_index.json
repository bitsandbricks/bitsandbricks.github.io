[
["poniendo-los-datos-en-forma.html", "Capítulo 3 Poniendo los datos en forma 3.1 Primeros pasos al examinar un conjunto de datos nuevo 3.2 Transformando los datos", " Capítulo 3 Poniendo los datos en forma Cómo ya hemos mencionado, es normal que la mayor parte del tiempo dedicado a un proyecto de análisis se nos vaya en la limpieza y orden de los datos disponibles. Aún cuando nuestros datos provengan de fuentes oficiales (un gobierno nacional, el Banco Mundial, etc) en muy rara ocasión podremos usarlos para nuestros fines sin antes procesarlos. Y aún si los datos llegaran en perfectas condiciones, no tenemos forma de saberlo hasta haber realizado una exploración para verificarlo. Ésta inevitable etapa de preparación es llamada data wrangling en inglés, algo así como elproceso de “domar los datos”. El término hace referencia, en clave de humor, al esfuerzo que la puesta en orden cuando los datos son cuantiosos, de muchas fuentes distintas, o en particular desprolijos. Para que la experiencia sea lo menos tediosa posible, y podamos pasar rápido al momento de extraer conocimiento, vamos a practicar algunas técnicas muy útiles. 3.1 Primeros pasos al examinar un conjunto de datos nuevo Vamos a practicar usando los registros del Sistema Único de Atención Ciudadana (SUACI) de la Ciudad Autónoma de Buenos Aires. El SUACI es el repositorio donde se integran las solicitudes y reclamos que los ciudadanos presentan a la ciudad por distintos canales: en persona, por teléfono o usando la aplicación BA 147. Vamos a trabajar con una versión de los datos que ha sido simplificada para hacer más ameno el trabajo con ella. Quién quiera acceder a los datos en su esplendor de complejidad original, puede encontrarlos en el portal de datos abiertos de la ciudad: https://data.buenosaires.gob.ar/ Comenzamos por acceder al archivo con los registros para cargarlo en R como un dataframe. Tendremos que ejercitar un poco la paciencia porque es un archuivo de varios megas, que podría tardar unos minutos en ser descargado. atencion_ciudadano &lt;- read.csv(&#39;http://bitsandbricks.github.io/data/gcba_suaci_barrios.csv&#39;) Lo primero que deberíamos hacer con un dataframe que no conocemos es usar la función str(), que nos indica su estructura (por structure en inglés): str(atencion_ciudadano) ## &#39;data.frame&#39;: 57432 obs. of 5 variables: ## $ PERIODO : int 201301 201301 201301 201301 201301 201301 201301 201301 201301 201301 ... ## $ RUBRO : Factor w/ 347 levels &quot;&quot;,&quot;ACCESOS&quot;,&quot;ACERAS&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ TIPO_PRESTACION: Factor w/ 6 levels &quot;&quot;,&quot;DENUNCIA&quot;,..: 4 4 4 4 4 4 4 4 4 4 ... ## $ BARRIO : Factor w/ 52 levels &quot;&quot;,&quot; &quot;,&quot;AGRONOMIA&quot;,..: 3 4 5 6 7 8 9 10 11 12 ... ## $ total : int 6 172 92 45 79 10 38 109 20 45 ... Lo primero que se nos informa es que nuestro objeto de análisis es un dataframe (“data.frame” ). Eso ya lo sabíamos, pero como str() puede usarse con cualquier clase de objeto en R, en un contexto distinto podría ser información nueva. A continuación aparecen las diemnsiones del dataframe: 164.33 observaciones (filas) con 5 variables (columnas). Los nombres de las columnas son PERIODO, RUBRO, TIPO_PRESTACION, BARRIO y total. Con eso ya podemos inferir que cada observación en el dataframe contiene la cantidad total de solicitudes según concepto, rubro y tipo de prestación (aunque no sepamos bien de que se tratan esas variables), en un período dado y en cada barrio. Con str() también obtenemos el tipo de datos representados pro cada variable, y un ejemplo de los valores contenidos en las primeras filas. PERIODO y total son variables de tipo “int”, es decir, números enteros o integers en inglés. El resto de las variables son de tipo “Factor”; en R las variables categóricas reciben el nombre de factores. ¿Y cómo sabe R que RUBRO o BARRIO son categorías? La culpable es la función read.csv() que usamos al principio. Si no se le aclara lo contrario, read_csv() interpreta como factores a todas las columnas que contienen texto. Para avisarle que no lo haga, hay que usar el parámetro stringsAsFactors, así: misdatos &lt;- read.csv('archivo_con_mis_datos', stringsAsFactors = FALSE). En general es buena idea evitar que los campos de texto se asuman como factores, pero en éste caso está bien: todas las columnas de texto, en efecto, contienen variables categóricas. (Ante la duda, una variable es categórica cuando es razonable considerar que se elige entre un conjunto finito de variables posibles; por ejemplo, los barrios de Buenos Aires son un conjunto finito y predeterminado). La siguiente función a utilizar cuando estamos conociendo el contenido de un set de datos es summary(), que nos dará un resumen en forma de estadísticas descriptivas para las variables numéricas (cuartiles y mediana) y un vistazo a las categorías más representadas par los factores. summary(atencion_ciudadano) ## PERIODO RUBRO TIPO_PRESTACION ## Min. :201301 SANEAMIENTO URBANO : 4589 : 1 ## 1st Qu.:201309 TRANSPORTE Y TRANSITO: 4580 DENUNCIA :21606 ## Median :201404 ARBOLADO : 3122 QUEJA : 3914 ## Mean :201401 ALUMBRADO : 2918 RECLAMO :21038 ## 3rd Qu.:201503 PAVIMENTO : 2411 SOLICITUD: 9662 ## Max. :201512 ESPACIO PUBLICO : 1918 TRAMITE : 1211 ## (Other) :37894 ## BARRIO total ## PALERMO : 2154 Min. : 1.00 ## BALVANERA : 1961 1st Qu.: 1.00 ## FLORES : 1959 Median : 4.00 ## CABALLITO : 1872 Mean : 34.85 ## SAN NICOLAS: 1748 3rd Qu.: 16.00 ## RECOLETA : 1729 Max. :19221.00 ## (Other) :46009 Las categorías posibles para un factor son llamadas “niveles” (levels). Para ver todos los niveles del factor BARRIO, es decir todos los barrios representados en la columna con la variable BARRIO, podemos usar la función levels() levels(atencion_ciudadano$BARRIO) ## [1] &quot;&quot; &quot; &quot; &quot;AGRONOMIA&quot; ## [4] &quot;ALMAGRO&quot; &quot;BALVANERA&quot; &quot;BARRACAS&quot; ## [7] &quot;BELGRANO&quot; &quot;BOCA&quot; &quot;BOEDO&quot; ## [10] &quot;CABALLITO&quot; &quot;CHACARITA&quot; &quot;COGHLAN&quot; ## [13] &quot;COLEGIALES&quot; &quot;CONSTITUCION&quot; &quot;ERRORNOHAYRESULTA&quot; ## [16] &quot;ERRORNOHAYRESULTADOS&quot; &quot;FLORES&quot; &quot;FLORESTA&quot; ## [19] &quot;LINIERS&quot; &quot;MATADEROS&quot; &quot;MONSERRAT&quot; ## [22] &quot;MONTE CASTRO&quot; &quot;NUEVA POMPEYA&quot; &quot;NUÑEZ&quot; ## [25] &quot;PALERMO&quot; &quot;PARQUE AVELLANEDA&quot; &quot;PARQUE CHACABUCO&quot; ## [28] &quot;PARQUE CHAS&quot; &quot;PARQUE PATRICIOS&quot; &quot;PATERNAL&quot; ## [31] &quot;PUERTO MADERO&quot; &quot;RECOLETA&quot; &quot;RETIRO&quot; ## [34] &quot;SAAVEDRA&quot; &quot;SAN CRISTOBAL&quot; &quot;SAN NICOLAS&quot; ## [37] &quot;SAN TELMO&quot; &quot;VELEZ SARSFIELD&quot; &quot;VERSALLES&quot; ## [40] &quot;VILLA CRESPO&quot; &quot;VILLA DEL PARQUE&quot; &quot;VILLA DEVOTO&quot; ## [43] &quot;VILLA GRAL. MITRE&quot; &quot;VILLA LUGANO&quot; &quot;VILLA LURO&quot; ## [46] &quot;VILLA ORTUZAR&quot; &quot;VILLA PUEYRREDON&quot; &quot;VILLA REAL&quot; ## [49] &quot;VILLA RIACHUELO&quot; &quot;VILLA SANTA RITA&quot; &quot;VILLA SOLDATI&quot; ## [52] &quot;VILLA URQUIZA&quot; Para acceder en forma rápida al contenido de la columna BARRIO, hemos utilizado por primera vez un “truco” muy práctico. Para obtener el contenido de cualquier columna en particular, basta con el nombre del dataframe seguido del símbolo $ y el nombre de la columna a extraer: atencion_ciudadano$BARRIO, o atencion_ciudadano$total, etc. 3.2 Transformando los datos Habiendo revisado el contenido de un dataframe, comenzamos a hacernos idea de los ajustes que necesita para que los datos tomen el formato que necesitamos. Estos ajustes pueden ser correcciones (por ejemplo, de errores de tipeo cuando se cargaron los datos), la creación de nuevas variables derivadas de las existentes, o un reordenamiento de los datos para simplificar nuestro trabajo. Para hacer todo esto, y mucho más, vamos a aprender funciones que representan cinco verbos básicos para la transformación de datos: select(): seleccionar -elegir- columnas por su nombre filter(): filtrar, es decir quedarse sólo con las filas que cumplan cierta condición arrange(): ordenar las filas de acuerdo a su contenido o algún otro índice mutate(): mutar -cambiar- un dataframe, modificando el contenido de sus columnas o creando columnas (es decir, variables) nuevas summarise(): producir sumarios -un valor extraído de muchos, por ejemplo el promedio- con el contenido de las columnas Estas funciones tienen una sintaxis, una forma de escribirse, uniforme. El primer argumento que toman siempre es un dataframe; los siguientes indican qué hacer con los datos. El resultado siempre es un nuevo dataframe. Las funciones son parte de (dplyr)[http://dplyr.tidyverse.org/], uno de los paquetes de funciones de la familia (Tidyverse)[https://www.tidyverse.org/]. Si no lo hicimos aún en la sesión en la que estamos trabajando, cargamos tidyverse. library(tidyverse) 3.2.1 Seleccionar columnas con select() Muchas veces tendremos que lidiar con datasets con decenas de variables. Alguna que otra vez, con centenas. En esos casos el primer problema es librarnos de semejante cantidad de columnas, reteniendo sólo aquellas en las que estamos interesados. Para un dataset como el de reclamos de los ciudadanos, que tiene pocas columnas, select() no es tan importante. Aún así, podemos usar select() con fines demostrativos. Sabemos que el dataset tiene 5 columnas: names(atencion_ciudadano) ## [1] &quot;PERIODO&quot; &quot;RUBRO&quot; &quot;TIPO_PRESTACION&quot; &quot;BARRIO&quot; ## [5] &quot;total&quot; Si quisiéramos sólo las que contienen el período y el total, las seleccionamos por nombre, a continuación del nonmbre del dataframe: seleccion &lt;- select(atencion_ciudadano, PERIODO, total) head(seleccion) ## PERIODO total ## 1 201301 6 ## 2 201301 172 ## 3 201301 92 ## 4 201301 45 ## 5 201301 79 ## 6 201301 10 También podemos seleccionar por contigüidad, por ejemplo “todas las columnas que van de RUBRO a BARRIO”: seleccion &lt;- select(atencion_ciudadano, RUBRO:BARRIO) head(seleccion) ## RUBRO TIPO_PRESTACION BARRIO ## 1 ACERAS RECLAMO AGRONOMIA ## 2 ACERAS RECLAMO ALMAGRO ## 3 ACERAS RECLAMO BALVANERA ## 4 ACERAS RECLAMO BARRACAS ## 5 ACERAS RECLAMO BELGRANO ## 6 ACERAS RECLAMO BOCA Y podemos seleccionar por omisión. Si nos interesara todo el contenido del dataset menos la variable RUBRO, usaríamos seleccion &lt;- select(atencion_ciudadano, -RUBRO) head(seleccion) ## PERIODO TIPO_PRESTACION BARRIO total ## 1 201301 RECLAMO AGRONOMIA 6 ## 2 201301 RECLAMO ALMAGRO 172 ## 3 201301 RECLAMO BALVANERA 92 ## 4 201301 RECLAMO BARRACAS 45 ## 5 201301 RECLAMO BELGRANO 79 ## 6 201301 RECLAMO BOCA 10 Al igual que con las selección por inclusión, podemos seleccionar por omisión de un rango de columnas contiguas (escritas entre paréntesis), o de varias columnas nombradas: seleccion &lt;- select(atencion_ciudadano, -(TIPO_PRESTACION:total)) head(seleccion) ## PERIODO RUBRO ## 1 201301 ACERAS ## 2 201301 ACERAS ## 3 201301 ACERAS ## 4 201301 ACERAS ## 5 201301 ACERAS ## 6 201301 ACERAS seleccion &lt;- select(atencion_ciudadano, -RUBRO, -BARRIO) head(seleccion) ## PERIODO TIPO_PRESTACION total ## 1 201301 RECLAMO 6 ## 2 201301 RECLAMO 172 ## 3 201301 RECLAMO 92 ## 4 201301 RECLAMO 45 ## 5 201301 RECLAMO 79 ## 6 201301 RECLAMO 10 3.2.2 Filtrar filas con filter() Una de las tareas más frecuentes en el análisis de datos es la de identificar observaciones que cumplen con determinada condición. filter() permite extraer subconjuntos del total en base a sus variables. Por ejemplo, para seleccionar registros que correspondan a Retiro, ocurridos en el primer mes de 2014 (período 201401): seleccion &lt;- filter(atencion_ciudadano, BARRIO == &quot;RETIRO&quot;, PERIODO == 201401) head(seleccion) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201401 ACERAS RECLAMO RETIRO 10 ## 2 201401 ALUMBRADO RECLAMO RETIRO 34 ## 3 201401 ALUMBRADO SOLICITUD RETIRO 2 ## 4 201401 ARBOLADO RECLAMO RETIRO 10 ## 5 201401 ARBOLADO SOLICITUD RETIRO 3 ## 6 201401 ATENCION AL PUBLICO QUEJA RETIRO 3 3.2.2.1 Comparaciones Aquí hemos usado un recurso nuevo, la comparación. R provee una serie de símbolos que permite comparar valores entre sí: * `==` igual a * `!=` no igual a * `&gt;` mayor a * `&gt;=` mayor o igual a * `&lt;` menor a * `&lt;=` menor o igual a Atención especial merece el símbolo que compara igualdad, ==. Un error muy común es escribir BARRIO = &quot;RETIRO&quot;, (un sólo símbolo =) que le indica a R que guarde el valor “RETIRO” dentro de la variable BARRIO, en lugar de verificar si son iguales. Para ésto último, lo correcto es BARRIO == &quot;RETIRO&quot;, tal como lo usamos en el ejemplo de filter(). Tabien hay que tener en cuenta el uso de comillas. Para que R no se confunda, cuando queramos usar valores de texto (de tipo character) los rodeamos con comillas para que quede claro que no nos referimos a una variable con ese nombre, si la hubiera, sino en forma literal a esa palabra o secuencia de texto. En el caso de los números, no hace falta el uso de comillas, ya que en R ningun nombre de variable puede comenzar con o estar compuuesta sólo por números. Filtrando los registros de períodos para los cuales se registran más de 100 incidentes: seleccion &lt;- filter(atencion_ciudadano, total &gt; 100) head(seleccion) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201301 ACERAS RECLAMO ALMAGRO 172 ## 2 201301 ACERAS RECLAMO CABALLITO 109 ## 3 201301 ACERAS RECLAMO FLORES 111 ## 4 201301 ACERAS RECLAMO PALERMO 113 ## 5 201301 ALUMBRADO RECLAMO ALMAGRO 130 ## 6 201301 ALUMBRADO RECLAMO BARRACAS 118 3.2.2.2 Operadores lógicos Cuando le pasamos múltiples condiciones a filter(), la función devuelve las filas que cumplen con todas. Por ejemplo, con seleccion &lt;- filter(atencion_ciudadano, PERIODO == 201508, RUBRO == &quot;SALUD&quot;) head(seleccion) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201508 SALUD QUEJA BARRACAS 1 ## 2 201508 SALUD QUEJA CABALLITO 1 ## 3 201508 SALUD QUEJA COGHLAN 1 ## 4 201508 SALUD QUEJA RECOLETA 1 obtenemos todos los registros cuyo rubro es “SALUD”, y cuyo período es 20108, agosto de 2015. Siguiendo el mismo formato, si intentamos seleccion &lt;- filter(atencion_ciudadano, BARRIO == &quot;RETIRO&quot;, BARRIO == &quot;PALERMO&quot;) head(seleccion) ## [1] PERIODO RUBRO TIPO_PRESTACION BARRIO ## [5] total ## &lt;0 rows&gt; (or 0-length row.names) obtenemos un conjunto vacío. ¿Por qué? Es debido a que ninguna observación cumple con todas las condiciones; el ningún registro el barrio es Retiro y es Palermo. ¡Suena razonable!. Para obtener registros ocurrido en Retiro ó en Palermo, usamos el operador lógico | que significa… “ó”. seleccion &lt;- filter(atencion_ciudadano, BARRIO == &quot;RETIRO&quot; | BARRIO == &quot;PALERMO&quot;) head(seleccion) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201301 ACERAS RECLAMO PALERMO 113 ## 2 201301 ACERAS RECLAMO RETIRO 15 ## 3 201301 ACERAS SOLICITUD PALERMO 2 ## 4 201301 ACTOS DE CORRUPCION DENUNCIA PALERMO 4 ## 5 201301 ALUMBRADO RECLAMO PALERMO 74 ## 6 201301 ALUMBRADO RECLAMO RETIRO 15 Se trata de la lógica de conjuntos, o lógica booleana, que con un poco de suerte recordamos de nuestra época de escolares. Los símbolos importantes son &amp;, |, y !: “y”, “’ó”, y la negación que invierte preposiciones: * `a &amp; b` a y b * `a | b` a ó b * `a &amp; !b` a, y no b * `!a &amp; b` no a, y b * `!(a &amp; b)` no (a y b) Hemos visto ejemplos de a &amp; b (PERIODO == 201508, RUBRO == &quot;SALUD&quot;, que filter toma como un &amp;) y de a | b (BARRIO == &quot;RETIRO&quot; | BARRIO == &quot;PALERMO&quot;) Un ejemplo de a &amp; !b, filas en las que el tipo de prestación sea “TRAMITE”, y en las que el rubro no sea “REGISTRO CIVIL”: filter(atencion_ciudadano, TIPO_PRESTACION == &quot;TRAMITE&quot; &amp; !(RUBRO == &quot;REGISTRO CIVIL&quot;)) Y como ejemplo de !(a &amp; b), todas las filas excepto las de tipo “DENUNCIA”, y rubro “SEGURIDAD E HIGIENE”: seleccion &lt;- filter(atencion_ciudadano, !(TIPO_PRESTACION == &quot;DENUNCIA&quot; &amp; RUBRO == &quot;SEGURIDAD E HIGIENE&quot;)) head(seleccion) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201301 ACERAS RECLAMO AGRONOMIA 6 ## 2 201301 ACERAS RECLAMO ALMAGRO 172 ## 3 201301 ACERAS RECLAMO BALVANERA 92 ## 4 201301 ACERAS RECLAMO BARRACAS 45 ## 5 201301 ACERAS RECLAMO BELGRANO 79 ## 6 201301 ACERAS RECLAMO BOCA 10 3.2.3 Ordenar filas con arrange() La funcion arrange() cambia el orden en el que aparecen las filas de un dataframe. Como primer parámetro toma un dataframe, al igual que el resto de los verbos de transformación que estamos aprendiendo. A continación, espera un set de columnas para definir el orden. Por ejemplo, para ordenar por total de registros: ordenado &lt;- arrange(atencion_ciudadano, total) head(ordenado) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201301 ACERAS RECLAMO PUERTO MADERO 1 ## 2 201301 ACERAS SOLICITUD BARRACAS 1 ## 3 201301 ACERAS SOLICITUD BOCA 1 ## 4 201301 ACERAS SOLICITUD BOEDO 1 ## 5 201301 ACERAS SOLICITUD COGHLAN 1 ## 6 201301 ACERAS SOLICITUD CONSTITUCION 1 Si agregamos más columnas, se usan en orden para “desempatar”. Por ejemplo, si queremos que las filas con el mismo valor en total aparezcan en el orden alfabético del barrio que les corresponde, sólo necesitamos agregar esa columna: ordenado &lt;- arrange(atencion_ciudadano, total, BARRIO) head(ordenado) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201409 1 ## 2 201301 ALUMBRADO SOLICITUD AGRONOMIA 1 ## 3 201301 ATENCION SOCIAL RECLAMO AGRONOMIA 1 ## 4 201301 ESPACIO PUBLICO RECLAMO AGRONOMIA 1 ## 5 201301 QUEJA QUEJA AGRONOMIA 1 ## 6 201301 RECUPERADORES RECLAMO AGRONOMIA 1 Si no se aclara lo contario, el orden siempre es ascendente (de menor a mayor). Si quisieramos orden de mayor a menor, usamos desc(): ordenado &lt;- arrange(atencion_ciudadano, desc(total)) head(ordenado) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total ## 1 201502 REGISTRO CIVIL TRAMITE MONSERRAT 19221 ## 2 201403 REGISTRO CIVIL TRAMITE SAN NICOLAS 19209 ## 3 201402 REGISTRO CIVIL TRAMITE SAN NICOLAS 17032 ## 4 201504 REGISTRO CIVIL TRAMITE MONSERRAT 16746 ## 5 201503 REGISTRO CIVIL TRAMITE MONSERRAT 16730 ## 6 201506 REGISTRO CIVIL TRAMITE MONSERRAT 14674 3.2.3.1 Valores faltantes En el último ejemplo, aparecen varias filas cuyo valor para la columna BARRIO es NA. R representa los valores ausentes, desconocidos, con NA (“no disponible”, del inglés Not Available). Hay que tener cuidado con los valores NA, porque la mayoría de las comparaciones y operaciones lógicas que los involucran resultan indefinidas. En la práctica: ¿Es 10 mayor a un valor desconocido? 10 &gt; NA ## [1] NA R no sabe. (Nadie lo sabe, para ser justos) ¿A cuanto asciende la suma de 10 más un valor desconocido? NA + 10 ## [1] NA Y en particular… ¿es un valor desconocido igual a otro valor desconocido? NA == NA ## [1] NA Por supuesto, la respuesta es desconocida también. La insistencia de R en no definir operaciones que involucran NA’s podría parecer irritante a primera vista, pero en realidad nos hace un favor. Al evitar extraer conclusiones cuando trata con datos faltantes, nos evita caer en errores garrafales en los casos en que analizamos y comparamos datos incompletos. Además, podemos preguntar a R si un valor es desconocido, y allí si contesta con seguridad. La función requerida es is.na(). desconocido &lt;- NA is.na(desconocido) ## [1] TRUE Algo más a tener en cuenta con los valores desconocidos es cómo son intepretados cuando usamos funciones de transformación de datos. Por ejemplo, filter() ignora las filas que contienen NA’s en la variable que usa para filtrar. arrange() muestra las filas con NA’s en el campo por el que ordena, pero todas al final. 3.2.4 Agregar nuevas variables con mutate() Recurrimos a la función mutate() cuando queremos agregarle columnas adicionales a nuestro dataframe, en general en base a los valores de las columnas ya existentes. Vamos a ilustrarlo con un ejemplo sencillo. Imaginemos que tenemos el siguiente dataset: circulos &lt;- data.frame(nombre = c(&quot;Círculo 1&quot;, &quot;Círculo 2&quot;, &quot;Círculo 3&quot;), tamaño = c(&quot;Pequeño&quot;, &quot;Mediano&quot;, &quot;Grande&quot;), radio = c(1, 3, 5)) circulos ## nombre tamaño radio ## 1 Círculo 1 Pequeño 1 ## 2 Círculo 2 Mediano 3 ## 3 Círculo 3 Grande 5 Podemos agregar una columna con el área de cada círculo con mutate(): mutate(circulos, area = 3.1416 * radio^2) ## nombre tamaño radio area ## 1 Círculo 1 Pequeño 1 3.1416 ## 2 Círculo 2 Mediano 3 28.2744 ## 3 Círculo 3 Grande 5 78.5400 Usando mutate(), definimos la columna “area”, indicando que su contenido será el valor de la columna “radio” en cada registro puesto en la fórmula del área de un círculo. Los operadores aritméticos (+, -, *, /, ^) son con frecuencia útiles para usar en conjunto con mutate(). Volvamos ahora a nuestro dataframe con datos de reclamos. Supongamos que nos interesa agregrar columnas con el mes y el año de cada registro. La columna período, con valores del tipo “201301”, contiene la información necesaria para derivar estas dos nuevas variables. Para separar la parte del año de la parte del mes, la función substr(), que extrae porciones de una variable de texto, nos va a dar una mano. La usamos así: el primer parámetro es una secuencia de caracteres, y los dos siguientes indican donde queremos que empiece y termine la porción a extraer. atencion_ciudadano &lt;- mutate(atencion_ciudadano, AÑO = substr(PERIODO, 1, 4), MES = substr(PERIODO, 5, 6)) head(atencion_ciudadano) ## PERIODO RUBRO TIPO_PRESTACION BARRIO total AÑO MES ## 1 201301 ACERAS RECLAMO AGRONOMIA 6 2013 01 ## 2 201301 ACERAS RECLAMO ALMAGRO 172 2013 01 ## 3 201301 ACERAS RECLAMO BALVANERA 92 2013 01 ## 4 201301 ACERAS RECLAMO BARRACAS 45 2013 01 ## 5 201301 ACERAS RECLAMO BELGRANO 79 2013 01 ## 6 201301 ACERAS RECLAMO BOCA 10 2013 01 3.2.5 Extraer sumarios con summarise() Llegamos al último de los verbos fundamentales para transformar datos. summarise() (por “resumir” en inglés) toma un dataframe completo y lo resume un una sola fila, de acuerdo a la operación que indiquemos. Por ejemplo, el promedio de la columna “total”: summarise(atencion_ciudadano, promedio = mean(total)) ## promedio ## 1 34.84721 Por si sola, summarise() no es de mucha ayuda. La gracia está en combinarla con group_by(), que cambia la unidad de análisis del dataframe completo a grupos individuales. Usar summarise() sobre un dataframe al que antes agrupamos con group_by resulta en resúmenes “por grupo”. agrupado &lt;- group_by(atencion_ciudadano, AÑO) summarise(agrupado, promedio_totales = mean(total)) ## # A tibble: 3 x 2 ## AÑO promedio_totales ## &lt;chr&gt; &lt;dbl&gt; ## 1 2013 29.5 ## 2 2014 30.2 ## 3 2015 45.4 Podemos agrupar por múltiples columnas, generando más subgrupos; por ejemplo, promedios por por año y mes… agrupado &lt;- group_by(atencion_ciudadano, AÑO, MES) sumario &lt;- summarise(agrupado, promedio = mean(total)) head(sumario) ## # A tibble: 6 x 3 ## # Groups: AÑO [1] ## AÑO MES promedio ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2013 01 25.1 ## 2 2013 02 26.1 ## 3 2013 03 26.9 ## 4 2013 04 29.5 ## 5 2013 05 28.0 ## 6 2013 06 28.9 … o por año, mes y barrio: agrupado &lt;- group_by(atencion_ciudadano, AÑO, MES, BARRIO) sumario &lt;- summarise(agrupado, promedio = mean(total)) head(sumario) ## # A tibble: 6 x 4 ## # Groups: AÑO, MES [1] ## AÑO MES BARRIO promedio ## &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 2013 01 AGRONOMIA 14.6 ## 2 2013 01 ALMAGRO 29.5 ## 3 2013 01 BALVANERA 23.6 ## 4 2013 01 BARRACAS 19.4 ## 5 2013 01 BELGRANO 24.4 ## 6 2013 01 BOCA 9.97 Con esto cerramos la sección de verbos de transformación de datos. Los cinco verbos aprendidos, usados en conjunto, brindan una enorme capacidad de medida que vayamos progresando en nuestra familiaridad con las funciones -y agregando técnicas nuevas- vamos a ser capaces de procesar grandes cantidades de datos con soltura. Y obtener en pocos minutos lo que de otra forma, sin herramientas computacionales, tardaría días o sería inviable por lo tedioso. "]
]
