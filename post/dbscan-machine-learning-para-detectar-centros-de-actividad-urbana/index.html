<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>DBSCAN: Machine Learning para detectar centros de actividad urbana</title>
  <meta property="og:title" content="DBSCAN: Machine Learning para detectar centros de actividad urbana" />
  <meta name="twitter:title" content="DBSCAN: Machine Learning para detectar centros de actividad urbana" />
  <meta name="description" content="El algoritmo DBSCAN DBSCAN es un algoritmo de machine learning diseñado para detectar en forma automática “clusters”, es decir elementos próximos entre si de acuerdo a sus atributos en varias dimensiones.
A diferencia de otros algoritmos de clustering como KMeans, DBSCAN resulta muy adecuado para buscar patrones de agrupación en el espacio físico. Por ejemplo, en la distribución espacial de actividades humanas.
Como se ilustra debajo, entre varias alternativas DBSCAN es la única cuyos resultados aproximan los de un analista humano que estuviera clasificando puntos aglomerados en un mapa (fuente).">
  <meta property="og:description" content="El algoritmo DBSCAN DBSCAN es un algoritmo de machine learning diseñado para detectar en forma automática “clusters”, es decir elementos próximos entre si de acuerdo a sus atributos en varias dimensiones.
A diferencia de otros algoritmos de clustering como KMeans, DBSCAN resulta muy adecuado para buscar patrones de agrupación en el espacio físico. Por ejemplo, en la distribución espacial de actividades humanas.
Como se ilustra debajo, entre varias alternativas DBSCAN es la única cuyos resultados aproximan los de un analista humano que estuviera clasificando puntos aglomerados en un mapa (fuente).">
  <meta name="twitter:description" content="El algoritmo DBSCAN DBSCAN es un algoritmo de machine learning diseñado para detectar en forma automática “clusters”, es decir elementos próximos entre si de acuerdo a sus atributos en varias …">
  <meta name="author" content="H. Antonio Vazquez Brust"/>
  <link href='/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="/img/avatar-icon.png" />
  <meta name="twitter:image" content="/img/avatar-icon.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@vazquezbrust" />
  <meta name="twitter:creator" content="@vazquezbrust" />
  <meta property="og:url" content="/post/dbscan-machine-learning-para-detectar-centros-de-actividad-urbana/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Bits &amp; Bricks" />

  <meta name="generator" content="Hugo 0.21" />
  <link rel="canonical" href="/post/dbscan-machine-learning-para-detectar-centros-de-actividad-urbana/" />
  <link rel="alternate" href="/index.xml" type="application/rss+xml" title="Bits &amp; Bricks">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="/css/pygment_highlights.css" />
  <link rel="stylesheet" href="/css/highlight.min.css" />




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css" integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css" integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin="anonymous" />



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-100821706-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Bits &amp; Bricks</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Blog" href="/">Blog</a>
            </li>
          
        
          
            <li>
              <a title="Manual de ciencia de datos" href="https://bitsandbricks.github.io/ciencia_de_datos_gente_sociable/">Manual de ciencia de datos</a>
            </li>
          
        
          
            <li>
              <a title="Acerca de" href="/page/about/">Acerca de</a>
            </li>
          
        

        

        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
          <a title="Bits &amp; Bricks" href="/">
            <img class="avatar-img" src="/img/avatar-icon.png" alt="Bits &amp; Bricks" />
          </a>
        
      </div>
    </div>

  </div>
</nav>




    
  
  
  




  
    <div id="header-big-imgs" data-num-img=1 data-img-src-1="/post/img/clusters.png" ></div>
  

  <header class="header-section has-img">
    
      <div class="intro-header big-img">
        
        <div class="container">
          <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <div class="post-heading">
                <h1>DBSCAN: Machine Learning para detectar centros de actividad urbana</h1>
                  
                  
                    <span class="post-meta">
  Posted on July 5, 2019
  
</span>


                  
              </div>
            </div>
          </div>
        </div>
        <span class="img-desc" style="display: inline;"></span>
      </div>
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              <h1>DBSCAN: Machine Learning para detectar centros de actividad urbana</h1>
                
                
                  <span class="post-meta">
  Posted on July 5, 2019
  
</span>


                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <div id="el-algoritmo-dbscan" class="section level2">
<h2>El algoritmo DBSCAN</h2>
<p>DBSCAN es un algoritmo de machine learning diseñado para detectar en forma automática “clusters”, es decir elementos próximos entre si de acuerdo a sus atributos en varias dimensiones.</p>
<p>A diferencia de otros algoritmos de clustering como <em>KMeans</em>, DBSCAN resulta muy adecuado para buscar patrones de agrupación en el espacio físico. Por ejemplo, en la distribución espacial de actividades humanas.</p>
<p>Como se ilustra debajo, entre varias alternativas DBSCAN es la única cuyos resultados aproximan los de un analista humano que estuviera clasificando puntos aglomerados en un mapa (<a href="https://www.hipparchus.org/hipparchus-clustering/">fuente</a>).</p>
<p><img src="https://www.hipparchus.org/hipparchus-clustering/images/userguide/cluster_comparison.png" width="100%" /></p>
<p>Pongámoslo a trabajar entonces, para identificar los centros comerciales (y de otros tipos de actividad) en la ciudad de Mendoza y sus alrededores. Un ejercicio como este, si se repitiera con cierta frecuencia, permitiría detectar la aparición, desplazamiento o desaparición de distintos centros de actividad especializada en la ciudad: zonas con oferta concentrada de bares, de servicios profesionales, de tiendas de bicicletas o lo que fuere.</p>
</div>
<div id="paquetes-a-utilizar" class="section level2">
<h2>Paquetes a utilizar</h2>
<p>Los herramientas generales de Tidyverse, siempre útiles para el proceso general de análisis de datos</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<p>y cinco paquetes especializados:</p>
<ul>
<li><code>sf</code> para leer y procesar datos geoespaciales</li>
<li><code>geosphere</code> para calcular distancias sobre la superficie terrestre</li>
<li><code>dbscan</code> para emplear el algoritmo homónimo de machine learning que permite encontrar <em>clusters</em> de elementos próximos</li>
<li><code>ggmap</code> para obtener y visualizar mapas detallados de la ciudad que analizaremos</li>
<li><code>ggrepel</code> para etiquetar en forma prolija nuestros mapas con gran cantidad de puntos</li>
</ul>
<pre class="r"><code>library(sf)
library(geosphere)
library(dbscan)
library(ggmap)
library(ggrepel)</code></pre>
</div>
<div id="los-datos" class="section level2">
<h2>Los datos</h2>
<p>Trabajaremos con un dataset de “puntos de interés”, o <em>PoI</em> en la jerga de aplicaciones espaciales (por “Points of Interest”).</p>
<pre class="r"><code>mdz_poi &lt;- read_csv(&#39;https://bitsandbricks.github.io/data/mendoza_poi.csv&#39;)

head(mdz_poi)</code></pre>
<pre><code>## # A tibble: 6 x 5
##   nombre                                        tipo  categoria   lat   lng
##   &lt;chr&gt;                                         &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;
## 1 Banco de la Nación Argentina                  atm   banca     -32.9 -68.8
## 2 Hospital Central BANCO DE LA NACION ARGENTIN… atm   banca     -32.9 -68.8
## 3 Banelco                                       atm   banca     -32.9 -68.8
## 4 Banelco                                       atm   banca     -32.9 -68.8
## 5 Cajero Automatico Banelco                     atm   banca     -32.9 -68.8
## 6 Citibank                                      bank  banca     -32.9 -68.8</code></pre>
<p>Se trata de lugares en el área urbbana de Mendoza, de 93 tipos distintos, agrupados en 12 categorías generales:</p>
<pre class="r"><code>count(mdz_poi, categoria, tipo)</code></pre>
<pre><code>## # A tibble: 93 x 3
##    categoria tipo                 n
##    &lt;chr&gt;     &lt;chr&gt;            &lt;int&gt;
##  1 banca     atm                 93
##  2 banca     bank               112
##  3 culto     church             248
##  4 culto     mosque               2
##  5 culto     place_of_worship     4
##  6 culto     synagogue            3
##  7 cultura   art_gallery         14
##  8 cultura   library             18
##  9 cultura   museum              55
## 10 educacion school             890
## # … with 83 more rows</code></pre>
<p>Los datos fueron compildos a mediados del 2017, a partir de consultas a la base de <a href="https://cloud.google.com/maps-platform/places/?&amp;sign=0">Google Places</a>. Google Places es la base de datos donde Google registra información sobre puntos de interés (comercios, prestadores de servicios, terminales de transporte y un largo etcétera) en cualquier parte del mundo. La forma habitual de acceder a partes de esta información es mediante la Google Maps, desde un navegador o una app de smartphone, pero también es posible consultar la base de forma automatizada, la forma en la cual se relevaron las datos que estamos usando.</p>
</div>
<div id="implementando-dbscan" class="section level2">
<h2>Implementando DBSCAN</h2>
<p>Para practicar, empecemor por detectar clusters de bares.</p>
<div id="i.-realizar-una-matriz-de-distancias" class="section level3">
<h3>I. Realizar una matriz de distancias</h3>
<p>El primer paso para aplicar el algorimto es obtener una matriz con la distancia que media entre todos los puntos a analiar. Dado que trabajamos con lugares situados sobre la superficie terrestre, debemos calcular distancias geográficas; es decir, tomar en cuenta la curvatura de la superficie. Para ellos podemos usar la función <code>distm()</code> del paquete <code>geosphere</code>.</p>
<p>Veamos como lucen nuestros bares en el mapa:</p>
<pre class="r"><code>mdz_bares &lt;- mdz_poi %&gt;% 
    filter(tipo == &quot;bar&quot;)

# Definir la &quot;caja&quot; de coordenadas donde entran los datos, para luego pedir el mapa
bbox &lt;- c(min(mdz_poi$lng),
          min(mdz_poi$lat),
          max(mdz_poi$lng),
          max(mdz_poi$lat))

mendoza &lt;- get_stamenmap(bbox = bbox, maptype = &quot;toner-background&quot;, zoom = 13)


ggmap(mendoza) +
    geom_point(data = mdz_bares, aes(x = lng, y = lat), color = &quot;orange&quot;, alpha = .5)</code></pre>
<p><img src="/post/2019-07-05-dbscan-machine-learning-para-detectar-centros-de-actividad-urbana.es_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>Ahora creamos la matriz con la distancia entre cada par de puntos (es decir, medimos la distancia de cada bar contra todos los demás), el insumo que requiere DBSCAN.</p>
<pre class="r"><code>distancias &lt;- mdz_bares %&gt;%
    select(lng, lat) %&gt;% # extraemos las columnas de longitud y latitud
    distm(fun = distGeo) %&gt;% # Calculamos las distancias de acuerdo a la curvatura de la Tierra
    as.dist() # convertimos en una matriz de distancias (el tipo de objeto que DBSCAN espera)</code></pre>
</div>
<div id="ii.-definir-parametros" class="section level3">
<h3>II. Definir parámetros</h3>
<p>Con la matriz de distancias a mano, es hora de decisiones. Tenemos que fijar dos parámetros, con el fin de indentificar zonas densas, medidas por la cantidad de objetos cercanos a cualquier punto dado:</p>
<ul>
<li><em>epsilon</em> es el radio de “vecindad” en torno a un punto.</li>
<li><em>minPts</em> es la cantidad mínima de vecinos dentro del radio <em>epsilon</em> que alcanzan para definir a ese punto como miembro de un cluster</li>
</ul>
<p>((fuente)[<a href="http://www.sthda.com/english/wiki/print.php?id=246#concepts-of-density-based-clustering" class="uri">http://www.sthda.com/english/wiki/print.php?id=246#concepts-of-density-based-clustering</a>])</p>
<p><img src="http://www.sthda.com/sthda/RDoc/images/dbscan-principle.png" /><!-- --></p>
<p>En (a) vemos a <em>x</em>, un punto “núcleo”(<em>core</em>). Son puntos “núcleo” aquellos que dentro de su radio <em>epsilon</em> tienen la cantidad mínima de vecinos definida como minPts. En (b) vemos tambiéb a <em>y</em> y a <em>z</em>. <em>y</em> es un punto “borde” porque su cantiadad de vecinos es menor a minPts, pero de todas formas se encuentra en la vecindad de un punto núcleo. Los puntos núcleo y brode que comparten vecindad son parte del mismo clúster. <em>z</em> es considerado “ruido” ya que no es núcleo ni borde, y por tanto no pertenece a un cluster.</p>
<p>Ahora bien, ¿cómo decidimos que cantidad es buena para minPts, y que distancia para <em>epsilon</em>? No hay receta infalible. Depende de cada caso, y se pueden encontrar por prueba y error. Para nuestro problema, decidamoslo así: vamos a considerar como cluster aquellas zonas donde, en un radio de una cuadra a la redonda de un bar dado (1 cuadra = 128 m, le), se encuentren al menos otros 5 bares. Tendremos entonces <em>epsilon</em> = 128 y minPts = 5.</p>
</div>
<div id="iii.-aplicar-el-algoritmo" class="section level3">
<h3>III. Aplicar el algoritmo</h3>
<p>Alla vamos:</p>
<pre class="r"><code>clusters &lt;- dbscan(distancias, eps = 128, minPts = 5)

clusters</code></pre>
<pre><code>## DBSCAN clustering for 321 objects.
## Parameters: eps = 128, minPts = 5
## The clustering contains 9 cluster(s) and 207 noise points.
## 
##   0   1   2   3   4   5   6   7   8   9 
## 207   8  43   6   6  22   6  12   6   5 
## 
## Available fields: cluster, eps, minPts</code></pre>
<p>Con nuestras reglas, encontramos 9 clusteres en la ciudad. Los bares cuyo valor asignado es 0 son “ruido”, los que no pertenecen a ningún cluster.</p>
<div id="iv.-visualizar-los-resultados" class="section level4">
<h4>IV. Visualizar los resultados</h4>
<p>Agreguemos a cada bar el cluster que le corresponde:</p>
<pre class="r"><code>mdz_bares &lt;- mdz_bares%&gt;% 
    cbind(cluster = clusters[[&quot;cluster&quot;]])</code></pre>
<p>Y con eso a podemos proyectar los resultados en un mapa:</p>
<pre class="r"><code># Visualizamos en un capa los bares sin cluster, y luego los que estan agrupados en otra
ggmap(mendoza) +
    geom_point(data = filter(mdz_bares, cluster == 0), 
               aes(x = lng, y = lat), 
               alpha = .5) +
    geom_point(data = filter(mdz_bares, cluster &gt; 0), 
               aes(x = lng, y = lat, color = factor(cluster)), 
               alpha = .5) +
    labs(title = &quot;Mendoza: clusters de bares&quot;,
         color = &quot;cluster&quot;)</code></pre>
<p><img src="/post/2019-07-05-dbscan-machine-learning-para-detectar-centros-de-actividad-urbana.es_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
</div>
</div>
</div>
<div id="automatizando-la-deteccion" class="section level2">
<h2>Automatizando la detección</h2>
<p>Vamos a crear una función que realice todos los pasos que vimos antes: realizar la matriz de distancia, fijar los parámetros de DBSCAN, aplicar el algoritmo, y agregar los identificadores de cluster a la data original.</p>
<p>Ya que vamos a lidiar con categorías generales (por ejemplo “servicios” incluye de todo, desde dentistas a funerarias) vamos a ponernos exigentes con los parámetros. Consideraremos que un punto pertenece a un cluster de actividad cuando tiene al menos 25 vecinos en una cuadra a la redonda. Con algunas excepciones: para banca, cultura, culto, educacion, entretenimiento, espacios_verdes, gobierno_y_serv_publicos, y “salud” dejaremos en 5 al umbral, ya que se trata de sitios de mayor “peso”. Seis bares en estrecha proximidad no representan una agrupación notable, pero con seis sedes de la administración pública, o seis museos, ya hablaríamos un centro de actividad.</p>
<p>Si no elegimos un valor par minPts, nuestra función se encargará de verificar el tipo de categoría a la que corresponden los puntos, y fijar el parámetro en forma acorde.</p>
<pre class="r"><code>assign_clusters &lt;- function(poi_df, minPts = NA) {
    
    # Para ciertas categorias, como educacion o salud, consideramos que a partir de n = 5 ya se 
    # forma clustering.
    # Para las demas (retail y servicios) el umbral se eleva a 25
    
    if(is.na(minPts)) {
        if(poi_df[1, &quot;categoria&quot;] %in% c(&quot;banca&quot;, &quot;cultura&quot;, &quot;culto&quot;, &quot;educacion&quot;, &quot;entretenimiento&quot;, 
                                         &quot;espacios_verdes&quot;, &quot;gobierno_y_serv_publicos&quot;, &quot;salud&quot;)) {
            minPts &lt;- 5
        } else minPts &lt;- 25
    }
    
    
    eps &lt;- 128 #  metros de distancia máxima entre miembros de un cluster
    
    poi_df[c(&quot;lng&quot;, &quot;lat&quot;)] %&gt;% 
        distm(fun = distHaversine) %&gt;%
        as.dist() %&gt;% 
        dbscan(eps = eps, minPts = minPts) %&gt;% 
        .[[&quot;cluster&quot;]] %&gt;% 
        cbind(poi_df, cluster = .)
    
}</code></pre>
<p>Ahora aplicamos la función a nuestros datos.</p>
<p>ATENCION! Con menos de 16 GB de RAM en el sistema, es posible que los recursos no alcancen para procesar el próximo bloque de código. El consumo de memoria de DBSCAN aumenta en forma exponencial (cuadrática) a medida que se incrementan la cantidad de puntos a analizar.</p>
<pre class="r"><code>mdz_poi &lt;- mdz_poi %&gt;%
    # separamos el dataset en una lista con un dataframe por cada categoría
    split(mdz_poi$categoria) %&gt;%  
    # Le aplicamos al dataframe de cada categoría la función de clustering
    map_df(assign_clusters) </code></pre>
<p>Listo!</p>
</div>
<div id="producto-final-un-grafico-facetado-por-categoria-con-todos-los-clusters-hallados" class="section level2">
<h2>Producto final: un gráfico facetado por categoría con todos los clusters hallados</h2>
<p>Antes de llevar los resultados al mapa, extraigamos para cada cluster su <em>convex hull</em>.</p>
<p><img src="https://miro.medium.com/max/1016/1*F4IUmOJbbLMJiTgHxpoc7Q.png" /><!-- --></p>
<p>La “envolvente convexa” de un cluster no es otra cosa que un polígono que encierra todos sus puntos. La idea us usarlas para mostrar en el mapa la extensión de las áreas que hemos identificado como centros de actividad.</p>
<pre class="r"><code>get_hull&lt;- function(df) {
    
    cbind(df$lng, df$lat) %&gt;% 
        as.matrix() %&gt;%
        st_multipoint() %&gt;% 
        st_convex_hull() %&gt;% 
        st_sfc(crs = 4326) %&gt;% 
        {st_sf(categoria = df$categoria[1], cluster = df$cluster[1], geom = .)}
}

hulls &lt;- function(df) {
    
    df %&gt;%
        split(.$cluster) %&gt;% 
        map(get_hull) %&gt;% 
        reduce(rbind)
    
}

mdz_cluster_hulls &lt;- mdz_poi %&gt;%
    filter(cluster != 0) %&gt;%
    select(lng, lat, categoria, cluster) %&gt;% 
    split(.$categoria) %&gt;% 
    map(hulls) %&gt;% 
    reduce(rbind) </code></pre>
<pre class="r"><code>#Para reducir la cantidad de etiquetas
hulls_por_cat &lt;- mdz_cluster_hulls %&gt;% 
    group_by(categoria) %&gt;% 
    summarise()

# A graficar

ggmap(mendoza) + 
  coord_sf(crs = st_crs(3857)) + # Necesario cuando se combinan ggmap y geom_sf
    geom_sf(data = hulls_por_cat, fill = NA, size = 1.5,
            aes(color = factor(categoria)), inherit.aes = FALSE) +
    geom_point(data = filter(mdz_poi, cluster == 0), size = .1, alpha =.1,
               aes(x = lng, y = lat)) +
    geom_point(data = filter(mdz_poi, cluster != 0), size = .2, alpha =.2,
               aes(x = lng, y = lat, color = factor(categoria))) + 
    ggrepel::geom_label_repel(data = hulls_por_cat,
                              aes(label = categoria, color = factor(categoria), geometry = geom),
                              stat = &quot;sf_coordinates&quot;,
                              inherit.aes = FALSE) +
    labs(y = &quot;&quot;, x = &quot;&quot;,
         title=&quot;Mendoza: clusters de actividad identificados&quot;,
         color = &quot;categoría&quot;) +
    # Eliminamos las etiquetas de latitud y longitud de los ejes 
    theme(axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank()) +
    guides(colour = FALSE)</code></pre>
<p><img src="/post/2019-07-05-dbscan-machine-learning-para-detectar-centros-de-actividad-urbana.es_files/figure-html/unnamed-chunk-17-1.png" width="768" /></p>
</div>

      </article>

      <ul class="pager blog-pager">
        
          <li class="previous">
            <a href="/post/taxis-en-buenos-aires-mapas-claros-y-negocios-turbios/" data-toggle="tooltip" data-placement="top" title="Taxis en Buenos Aires: mapas claros y negocios turbios">&larr; Previous Post</a>
          </li>
        
        
      </ul>

      
        
          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'bits-bricks';
    var disqus_identifier = '\/post\/dbscan-machine-learning-para-detectar-centros-de-actividad-urbana\/';
    var disqus_title = 'DBSCAN: Machine Learning para detectar centros de actividad urbana';
    var disqus_url = '\/post\/dbscan-machine-learning-para-detectar-centros-de-actividad-urbana\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
        
      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="mailto:avazquez@gmail.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://twitter.com/vazquezbrust" title="Twitter">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://linkedin.com/in/avazquez" title="LinkedIn">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://stackoverflow.com/users/3527951/havb" title="StackOverflow">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-stack-overflow fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="/index.xml" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          H. Antonio Vazquez Brust
          &nbsp;&bull;&nbsp;
          2019

          
            &nbsp;&bull;&nbsp;
            <a href="/">Bits &amp; Bricks</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.21</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="/js/main.js"></script>
<script src="/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js" integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js" integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk=" crossorigin="anonymous"></script>
<script src="/js/load-photoswipe.js"></script>




  </body>
</html>

