<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Bits &amp; Bricks</title>
    <link>/post/</link>
    <description>Recent content in Posts on Bits &amp; Bricks</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>avazquez@gmail.com (H. Antonio Vazquez Brust)</managingEditor>
    <webMaster>avazquez@gmail.com (H. Antonio Vazquez Brust)</webMaster>
    <lastBuildDate>Fri, 05 Jul 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DBSCAN: Machine Learning para detectar centros de actividad urbana</title>
      <link>/post/dbscan-machine-learning-para-detectar-centros-de-actividad-urbana/</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
      <author>avazquez@gmail.com (H. Antonio Vazquez Brust)</author>
      <guid>/post/dbscan-machine-learning-para-detectar-centros-de-actividad-urbana/</guid>
      <description>&lt;p&gt;DBSCAN es un algoritmo de &lt;em&gt;machine learning&lt;/em&gt; diseñado para detectar en forma automática “clusters”, es decir elementos próximos entre si de acuerdo a sus atributos en varias dimensiones.&lt;/p&gt;
&lt;p&gt;A diferencia de otros algoritmos de &lt;em&gt;clustering&lt;/em&gt; como &lt;em&gt;KMeans&lt;/em&gt;, DBSCAN resulta muy adecuado para buscar patrones de agrupación en el espacio físico. Por ejemplo, en la distribución espacial de actividades humanas.&lt;/p&gt;
&lt;p&gt;Como se ilustra debajo, entre varias alternativas DBSCAN es la única cuyos resultados aproximan los de un analista humano que estuviera clasificando puntos aglomerados en un mapa:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.hipparchus.org/hipparchus-clustering/images/userguide/cluster_comparison.png&#34; width=&#34;100%&#34; /&gt;
(imagen vía &lt;a href=&#34;https://www.hipparchus.org/hipparchus-clustering/&#34;&gt;hipparchus.org&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Pongámoslo a trabajar entonces, para identificar los centros comerciales (y de otros tipos de actividad) en la ciudad de Mendoza y sus alrededores. Un ejercicio como este, si se repitiera con cierta frecuencia, permitiría detectar la aparición, desplazamiento o desaparición de distintos centros de actividad especializada en la ciudad: zonas con oferta concentrada de bares, de servicios profesionales, de tiendas de bicicletas o lo que fuere.&lt;/p&gt;
&lt;div id=&#34;paquetes-a-utilizar&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Paquetes a utilizar&lt;/h2&gt;
&lt;p&gt;Los herramientas generales de Tidyverse, siempre útiles para el proceso general de análisis de datos:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;y cuatro paquetes especializados:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sf&lt;/code&gt; para leer y procesar datos geoespaciales&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geosphere&lt;/code&gt; para calcular distancias sobre la superficie terrestre&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dbscan&lt;/code&gt; para emplear el algoritmo homónimo de machine learning que permite encontrar &lt;em&gt;clusters&lt;/em&gt; de elementos próximos&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ggmap&lt;/code&gt; para obtener y visualizar mapas detallados de la ciudad que analizaremos&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)
library(geosphere)
library(dbscan)
library(ggmap)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;los-datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Los datos&lt;/h2&gt;
&lt;p&gt;Trabajaremos con un dataset de “puntos de interés”, o &lt;em&gt;PoI&lt;/em&gt; en la jerga de aplicaciones espaciales (por “Points of Interest”).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mdz_poi &amp;lt;- read_csv(&amp;#39;https://bitsandbricks.github.io/data/mendoza_poi.csv&amp;#39;)

head(mdz_poi)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 5
##   nombre                                        tipo  categoria   lat   lng
##   &amp;lt;chr&amp;gt;                                         &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 Banco de la Nación Argentina                  atm   banca     -32.9 -68.8
## 2 Hospital Central BANCO DE LA NACION ARGENTIN… atm   banca     -32.9 -68.8
## 3 Banelco                                       atm   banca     -32.9 -68.8
## 4 Banelco                                       atm   banca     -32.9 -68.8
## 5 Cajero Automatico Banelco                     atm   banca     -32.9 -68.8
## 6 Citibank                                      bank  banca     -32.9 -68.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se trata de lugares en el área urbana de Mendoza, de 93 tipos distintos, agrupados en 12 categorías generales:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;count(mdz_poi, categoria, tipo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 93 x 3
##    categoria tipo                 n
##    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;            &amp;lt;int&amp;gt;
##  1 banca     atm                 93
##  2 banca     bank               112
##  3 culto     church             248
##  4 culto     mosque               2
##  5 culto     place_of_worship     4
##  6 culto     synagogue            3
##  7 cultura   art_gallery         14
##  8 cultura   library             18
##  9 cultura   museum              55
## 10 educacion school             890
## # … with 83 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Los datos fueron compilados a mediados del 2017, a partir de consultas a la base de &lt;a href=&#34;https://cloud.google.com/maps-platform/places/?&amp;amp;sign=0&#34;&gt;Google Places&lt;/a&gt;. Google Places es la base de datos donde Google registra información sobre puntos de interés (comercios, prestadores de servicios, terminales de transporte y un largo etcétera) en cualquier parte del mundo. La forma habitual de acceder a partes de esta información es mediante la Google Maps, desde un navegador o una app de &lt;em&gt;smartphone&lt;/em&gt;, pero también es posible consultar la base de forma automatizada, el modo con el cual se relevaron las datos que estamos usando.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;implementando-dbscan&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Implementando DBSCAN&lt;/h2&gt;
&lt;p&gt;Para practicar, empecemos por detectar clusters de bares.&lt;/p&gt;
&lt;div id=&#34;i.-realizar-una-matriz-de-distancias&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;I. Realizar una matriz de distancias&lt;/h3&gt;
&lt;p&gt;El primer paso para aplicar el algoritmo es obtener una matriz con la distancia que media entre todos los puntos a analizar. Dado que trabajamos con lugares situados sobre la superficie terrestre, debemos calcular distancias geográficas; es decir, tomar en cuenta la curvatura de la superficie. Para ellos podemos usar la función &lt;code&gt;distm()&lt;/code&gt; del paquete &lt;code&gt;geosphere&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Veamos como lucen nuestros bares en el mapa:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mdz_bares &amp;lt;- mdz_poi %&amp;gt;% 
    filter(tipo == &amp;quot;bar&amp;quot;)

# Definir la &amp;quot;caja&amp;quot; de coordenadas donde entran los datos, para luego pedir el mapa
bbox &amp;lt;- c(min(mdz_poi$lng),
          min(mdz_poi$lat),
          max(mdz_poi$lng),
          max(mdz_poi$lat))

mendoza &amp;lt;- get_stamenmap(bbox = bbox, maptype = &amp;quot;toner-background&amp;quot;, zoom = 13)


ggmap(mendoza) +
    geom_point(data = mdz_bares, aes(x = lng, y = lat), color = &amp;quot;orange&amp;quot;, alpha = .5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-05-dbscan-machine-learning-para-detectar-centros-de-actividad-urbana.es_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ahora creamos la matriz con la distancia entre cada par de puntos (es decir, medimos la distancia de cada bar contra todos los demás), el insumo que requiere DBSCAN.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;distancias &amp;lt;- mdz_bares %&amp;gt;%
    select(lng, lat) %&amp;gt;% # extraemos las columnas de longitud y latitud
    distm(fun = distGeo) %&amp;gt;% # Calculamos las distancias de acuerdo a la curvatura de la Tierra
    as.dist() # convertimos en una matriz de distancias (el tipo de objeto que DBSCAN espera)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;ii.-definir-parametros&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;II. Definir parámetros&lt;/h3&gt;
&lt;p&gt;Con la matriz de distancias a mano, es hora de decisiones. Tenemos que fijar dos parámetros, con el fin de identificar zonas densas, medidas por la cantidad de objetos cercanos a cualquier punto dado:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;epsilon&lt;/em&gt; es el radio de “vecindad” en torno a un punto.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;minPts&lt;/em&gt; es la cantidad mínima de vecinos dentro del radio &lt;em&gt;epsilon&lt;/em&gt; que alcanzan para definir a ese punto como miembro de un cluster&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;((fuente)[&lt;a href=&#34;http://www.sthda.com/english/wiki/print.php?id=246#concepts-of-density-based-clustering&#34; class=&#34;uri&#34;&gt;http://www.sthda.com/english/wiki/print.php?id=246#concepts-of-density-based-clustering&lt;/a&gt;])&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sthda.com/sthda/RDoc/images/dbscan-principle.png&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;p&gt;En (a) vemos a &lt;em&gt;x&lt;/em&gt;, un punto “núcleo”(&lt;em&gt;core&lt;/em&gt;). Son puntos “núcleo” aquellos que dentro de su radio &lt;em&gt;epsilon&lt;/em&gt; tienen la cantidad mínima de vecinos definida como minPts. En (b) vemos también a &lt;em&gt;y&lt;/em&gt; y a &lt;em&gt;z&lt;/em&gt;. &lt;em&gt;y&lt;/em&gt; es un punto “borde” porque su cantidad de vecinos es menor a minPts, pero de todas formas se encuentra en la vecindad de un punto núcleo. Los puntos núcleo y borde que comparten vecindad son parte del mismo cluster. &lt;em&gt;z&lt;/em&gt; es considerado “ruido” ya que no es núcleo ni borde, y por tanto no pertenece a un cluster.&lt;/p&gt;
&lt;p&gt;Ahora bien, ¿cómo decidimos que cantidad es buena para minPts, y que distancia para &lt;em&gt;epsilon&lt;/em&gt;? No hay receta infalible. Depende de cada caso, y se pueden encontrar por prueba y error. Para nuestro problema, decidámoslo así: vamos a considerar como cluster aquellas zonas donde, en un radio de una cuadra (128 metros) a la redonda de un bar dado, se encuentren al menos otros 5 bares. Tendremos entonces &lt;em&gt;epsilon&lt;/em&gt; = 128 y minPts = 5.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;iii.-aplicar-el-algoritmo&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;III. Aplicar el algoritmo&lt;/h3&gt;
&lt;p&gt;Allá vamos:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;clusters &amp;lt;- dbscan(distancias, eps = 128, minPts = 5)

clusters&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## DBSCAN clustering for 321 objects.
## Parameters: eps = 128, minPts = 5
## The clustering contains 9 cluster(s) and 207 noise points.
## 
##   0   1   2   3   4   5   6   7   8   9 
## 207   8  43   6   6  22   6  12   6   5 
## 
## Available fields: cluster, eps, minPts&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Con nuestras reglas, encontramos 9 clusters en la ciudad. Los bares cuyo valor asignado es 0 son “ruido”, los que no pertenecen a ningún cluster.&lt;/p&gt;
&lt;div id=&#34;iv.-visualizar-los-resultados&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;IV. Visualizar los resultados&lt;/h4&gt;
&lt;p&gt;Agreguemos a cada bar el cluster que le corresponde:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mdz_bares &amp;lt;- mdz_bares%&amp;gt;% 
    cbind(cluster = clusters[[&amp;quot;cluster&amp;quot;]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y con eso a podemos proyectar los resultados en un mapa:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Visualizamos en un capa los bares sin cluster, y luego los que estan agrupados en otra
ggmap(mendoza) +
    geom_point(data = filter(mdz_bares, cluster == 0), 
               aes(x = lng, y = lat), 
               alpha = .5) +
    geom_point(data = filter(mdz_bares, cluster &amp;gt; 0), 
               aes(x = lng, y = lat, color = factor(cluster)), 
               alpha = .5) +
    labs(title = &amp;quot;Mendoza: clusters de bares&amp;quot;,
         color = &amp;quot;cluster&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-05-dbscan-machine-learning-para-detectar-centros-de-actividad-urbana.es_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;automatizando-la-deteccion&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Automatizando la detección&lt;/h2&gt;
&lt;p&gt;Vamos a crear una función que realice todos los pasos que vimos antes: realizar la matriz de distancia, fijar los parámetros de DBSCAN, aplicar el algoritmo, y agregar los identificadores de cluster a la data original.&lt;/p&gt;
&lt;p&gt;Ya que vamos a lidiar con categorías generales (por ejemplo “servicios” incluye de todo, desde dentistas a funerarias) vamos a ponernos exigentes con los parámetros. Consideraremos que un punto pertenece a un cluster de actividad cuando tiene al menos 25 vecinos en una cuadra a la redonda. Con algunas excepciones: para banca, cultura, culto, educación, entretenimiento, espacios_verdes, gobierno_y_serv_publicos y salud, dejaremos en 5 al umbral. Estos son sitios de mayor “peso”. Seis bares en estrecha proximidad no representan una agrupación notable, pero con seis sedes de la administración pública, o seis museos, ya hablaríamos un centro de actividad.&lt;/p&gt;
&lt;p&gt;Si bien permite especificar minPts si lo quisiéramos, nuestra función se encargará de verificar el tipo de categoría a la que corresponden los puntos, y fijar el parámetro en forma acorde.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;assign_clusters &amp;lt;- function(poi_df, minPts = NA) {
    
    # Para ciertas categorias, como educacion o salud, consideramos que a partir de n = 5 ya se 
    # forma clustering.
    # Para las demas (retail y servicios) el umbral se eleva a 25
    
    if(is.na(minPts)) {
        if(poi_df[1, &amp;quot;categoria&amp;quot;] %in% c(&amp;quot;banca&amp;quot;, &amp;quot;cultura&amp;quot;, &amp;quot;culto&amp;quot;, &amp;quot;educacion&amp;quot;, &amp;quot;entretenimiento&amp;quot;, 
                                         &amp;quot;espacios_verdes&amp;quot;, &amp;quot;gobierno_y_serv_publicos&amp;quot;, &amp;quot;salud&amp;quot;)) {
            minPts &amp;lt;- 5
        } else minPts &amp;lt;- 25
    }
    
    
    eps &amp;lt;- 128 #  metros de distancia máxima entre miembros de un cluster
    
    poi_df[c(&amp;quot;lng&amp;quot;, &amp;quot;lat&amp;quot;)] %&amp;gt;% 
        distm(fun = distHaversine) %&amp;gt;%
        as.dist() %&amp;gt;% 
        dbscan(eps = eps, minPts = minPts) %&amp;gt;% 
        .[[&amp;quot;cluster&amp;quot;]] %&amp;gt;% 
        cbind(poi_df, cluster = .)
    
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora aplicamos la función a nuestros datos.&lt;/p&gt;
&lt;p&gt;ATENCION! Con menos de 16 GB de RAM en el sistema, es posible que los recursos no alcancen para procesar el próximo bloque de código. El consumo de memoria de DBSCAN aumenta en forma exponencial (cuadrática) a medida que se incrementan la cantidad de puntos a analizar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mdz_poi &amp;lt;- mdz_poi %&amp;gt;%
    # separamos el dataset en una lista con un dataframe por cada categoría
    split(mdz_poi$categoria) %&amp;gt;%  
    # Le aplicamos al dataframe de cada categoría la función de clustering
    map_df(assign_clusters) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Listo!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;producto-final-un-mapa-con-todos-los-clusters-hallados-por-categoria&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Producto final: un mapa con todos los clusters hallados por categoría&lt;/h2&gt;
&lt;p&gt;Antes de llevar los resultados al mapa, extraigamos para cada cluster su &lt;em&gt;convex hull&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/max/1016/1*F4IUmOJbbLMJiTgHxpoc7Q.png&#34; /&gt;&lt;!-- --&gt;
(gráfico cortesía de &lt;a href=&#34;https://medium.com/@harshitsikchi/convex-hulls-explained-baab662c4e94&#34;&gt;Harshit Sikchi&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;La “envolvente convexa” de un cluster no es otra cosa que un polígono que encierra todos sus puntos. La idea es usarlas para mostrar en el mapa la extensión de las áreas que hemos identificado como centros de actividad.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_hull&amp;lt;- function(df) {
    
    cbind(df$lng, df$lat) %&amp;gt;% 
        as.matrix() %&amp;gt;%
        st_multipoint() %&amp;gt;% 
        st_convex_hull() %&amp;gt;% 
        st_sfc(crs = 4326) %&amp;gt;% 
        {st_sf(categoria = df$categoria[1], cluster = df$cluster[1], geom = .)}
}

hulls &amp;lt;- function(df) {
    
    df %&amp;gt;%
        split(.$cluster) %&amp;gt;% 
        map(get_hull) %&amp;gt;% 
        reduce(rbind)
    
}

mdz_cluster_hulls &amp;lt;- mdz_poi %&amp;gt;%
    filter(cluster != 0) %&amp;gt;%
    select(lng, lat, categoria, cluster) %&amp;gt;% 
    split(.$categoria) %&amp;gt;% 
    map(hulls) %&amp;gt;% 
    reduce(rbind) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lo que hemos obtenido con el paso previo es una serie de polígonos, que representan las envolventes de los clusters que hallamos. Si echamos un vistazo, notamos que la venta al público (retail) es la actividad dominante, seguida de servicios -muy razonable.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(mdz_cluster_hulls) + 
  geom_sf(aes(fill = categoria), alpha = .7, color = NA)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-05-dbscan-machine-learning-para-detectar-centros-de-actividad-urbana.es_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Y por último, todos los ingredientes previos -mapa base, PoI, clusters, envolventes- en una visualización:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#Para reducir la cantidad de etiquetas
hulls_por_cat &amp;lt;- mdz_cluster_hulls %&amp;gt;% 
    group_by(categoria) %&amp;gt;% 
    summarise()

# A graficar

ggmap(mendoza) + 
  coord_sf(crs = st_crs(3857)) + # Necesario cuando se combinan ggmap y geom_sf
    geom_sf(data = hulls_por_cat, fill = NA, size = 1.5, alpha = .5,
            aes(color = factor(categoria)), inherit.aes = FALSE) +
    geom_point(data = filter(mdz_poi, cluster == 0), size = .1, alpha =.1,
               aes(x = lng, y = lat)) +
    geom_point(data = filter(mdz_poi, cluster != 0), size = .2, alpha =.2,
               aes(x = lng, y = lat, color = factor(categoria))) +
    # definimos la escala de colores 
    scale_color_brewer(palette = &amp;quot;Paired&amp;quot;) +
    labs(y = &amp;quot;&amp;quot;, x = &amp;quot;&amp;quot;,
         title=&amp;quot;Mendoza: clusters de actividad identificados&amp;quot;,
         color = &amp;quot;categoría&amp;quot;) +
    # Eliminamos las etiquetas de latitud y longitud de los ejes 
    theme(axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank()) +
    guides(colour = guide_legend(override.aes = list(size=4, alpha = 1))) +
    theme(legend.position=&amp;quot;bottom&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-05-dbscan-machine-learning-para-detectar-centros-de-actividad-urbana.es_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Taxis en Buenos Aires: mapas claros y negocios turbios</title>
      <link>/post/taxis-en-buenos-aires-mapas-claros-y-negocios-turbios/</link>
      <pubDate>Sat, 13 Jan 2018 00:00:00 +0000</pubDate>
      <author>avazquez@gmail.com (H. Antonio Vazquez Brust)</author>
      <guid>/post/taxis-en-buenos-aires-mapas-claros-y-negocios-turbios/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/jquery/jquery.min.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/leaflet/leaflet.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet/leaflet.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/leafletfix/leafletfix.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;link href=&#34;/rmarkdown-libs/leaflet-label/leaflet.label.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet-label/leaflet.label.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/Proj4Leaflet/proj4-compressed.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/Proj4Leaflet/proj4leaflet.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet-binding/leaflet.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet-providers/leaflet-providers.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet-providers-plugin/leaflet-providers-plugin.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/HomeButton/home-button.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/HomeButton/home-button.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/HomeButton/easy-button-src.min.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;Hace unos meses, durante la &lt;a href=&#34;http://smartcityexpobuenosaires.com/&#34;&gt;Smart City Expo en Buenos Aires&lt;/a&gt; se organizó un &lt;a href=&#34;https://www.eventbrite.com.ar/e/dataton-un-dia-en-las-ciudades-a-traves-de-sus-datos-tickets-37843936232#&#34;&gt;&lt;strong&gt;Datatón&lt;/strong&gt;&lt;/a&gt; bajo el título de “Un día en las ciudades a través de sus datos”. El evento fue organizado por los equipos de datos abiertos de la Nación, y la Ciudad y Provincia&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; de Buenos Aires.&lt;/p&gt;
&lt;p&gt;Con motivo del evento se hicieron públicos varios datasets con información urbana. Entre ellos, una muestra de viajes en taxi solicitados mediante la app &lt;a href=&#34;http://www.buenosaires.gob.ar/taxis/ba-taxi-innovacion-para-mejorar-tus-viajes&#34;&gt;BA TAXI&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;information-is-beautiful&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Information is beautiful&lt;/h2&gt;
&lt;p&gt;Cuando vi pasar el dataset, lo primero que se me ocurrió fue visualizar todos los viajes a la vez, al estilo del mapa que hizo el MIT Senseable City Lab para &lt;a href=&#34;http://hubcab.org&#34;&gt;los taxis de Nueva York&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/img/hubcab.jpg&#34; alt=&#34;hubcab.org&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;hubcab.org&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;En resumidas cuentas, obtuve lo que buscaba, y algo más. En un ejemplo de los patrones que son difíciles de detectar en una lista de números, pero resultan evidentes una vez visualizados, en mi mapa relucen rastros de lo que a los porteños nos gusta llamar “la mafia de los taxis”.&lt;/p&gt;
&lt;p&gt;Pero vayamos por partes.&lt;/p&gt;
&lt;div id=&#34;haciendo-el-mapa&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Haciendo el mapa&lt;/h3&gt;
&lt;p&gt;Los ingredientes necesarios son (además de R u otro entorno de programación analítica),&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;El dataset de BA Taxi, disponible &lt;a href=&#34;https://data.world/vazquez-brust/viajes-solicitados-por-ba-taxi&#34;&gt;aquí&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Un archivo georeferenciado con las calles de Buenos Aires, disponible en el portal de datos abiertos de la Ciudad &lt;a href=&#34;https://data.buenosaires.gob.ar/dataset/calles&#34;&gt;como shapefile&lt;/a&gt;, o &lt;a href=&#34;https://data.world/vazquez-brust/calles-de-la-ciudad-autonoma-de-buenos-aires&#34;&gt;aquí en el mucho más práctico formato geojson&lt;/a&gt;. Yo voy a usar éste último.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ahora, la receta.&lt;/p&gt;
&lt;p&gt;I. Cargamos la data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(rgdal)
library(hrbrthemes)


taxis &amp;lt;- read.csv(&amp;#39;../data/bataxi.csv&amp;#39;, sep = &amp;quot;;&amp;quot;, stringsAsFactors = F)
calles &amp;lt;- fortify(readOGR(&amp;#39;../data/calles_CABA.geojson&amp;#39;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## OGR data source with driver: GeoJSON 
## Source: &amp;quot;../data/calles_CABA.geojson&amp;quot;, layer: &amp;quot;calles_CABA&amp;quot;
## with 30037 features
## It has 1 fields&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Leve limpieza: pasamos las coordenadas a formato numérico

taxis &amp;lt;- taxis %&amp;gt;% 
    mutate(origen_viaje_x = as.numeric(gsub(&amp;quot;,&amp;quot;, &amp;quot;.&amp;quot;, origen_viaje_x)),
           origen_viaje_y = as.numeric(gsub(&amp;quot;,&amp;quot;, &amp;quot;.&amp;quot;, origen_viaje_y)),
           destino_viaje_x = as.numeric(gsub(&amp;quot;,&amp;quot;, &amp;quot;.&amp;quot;, destino_viaje_x)),
           destino_viaje_y = as.numeric(gsub(&amp;quot;,&amp;quot;, &amp;quot;.&amp;quot;, destino_viaje_y)))&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: upper-roman&#34;&gt;
&lt;li&gt;Echamos un vistazo rápido a las coordenadas de los viajes:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data = taxis) + 
    geom_point(aes(x = origen_viaje_x, y = origen_viaje_y), 
               size = 0.06, 
               alpha = .5) + 
  coord_map()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;La data es lo suficientemente densa como para que se entrevea la estructura vial de la ciudad. Excelente! Ahora vamos a refinar la visualización.&lt;/p&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: upper-roman&#34;&gt;
&lt;li&gt;Separamos las coordenadas en “orígenes” (donde el taxi levantó pasajeros) y destinos, los lugares de llegada.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;taxis_origenes &amp;lt;- taxis %&amp;gt;% 
    group_by(origen_viaje_x, origen_viaje_y) %&amp;gt;% 
    summarise(n = n(), 
              tipo = &amp;quot;origen&amp;quot;) %&amp;gt;% 
    rename(lon = origen_viaje_x,
           lat = origen_viaje_y)

taxis_destinos &amp;lt;- taxis %&amp;gt;% 
    group_by(destino_viaje_x, destino_viaje_y) %&amp;gt;% 
    summarise(n = n(),
              tipo = &amp;quot;destino&amp;quot;) %&amp;gt;% 
    rename(lon = destino_viaje_x,
           lat = destino_viaje_y)&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: upper-roman&#34;&gt;
&lt;li&gt;Creamos un “template” para el mapa que use fondo negro, que siempre queda &lt;em&gt;flashero&lt;/em&gt; con info proyectada encima en colores brillantes. También definimos color y tamaño de título y subtítulo, y vamos a por un look mínimo retirando todos los componentes posibles: chau grilla de fondo, chau leyendas en los ejes, etc.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;theme_ipsum_map_dark &amp;lt;- function(base_size = 24, title_size = 60, 
                                 subtitle_size = 48, caption_size = 40) {
    
    color.background = &amp;quot;black&amp;quot;
    color.title = &amp;quot;gray80&amp;quot;
    color.axis.title = &amp;quot;gray80&amp;quot;
    
    theme_ipsum(base_size=base_size) +
        theme(rect=element_rect(fill=color.background, color=color.background)) +
        theme(plot.background=element_rect(fill=color.background
                                           , color=color.background)) +
        theme(panel.border=element_rect(color=color.background, fill = NA)) +
        theme(panel.background = element_rect(fill = color.background)) +
        theme(panel.grid.major=element_blank()) +
        theme(panel.grid.minor=element_blank()) +
        theme(axis.ticks=element_blank()) +
        theme(legend.background = element_rect(fill=color.background)) +
        theme(legend.text = element_text(colour=color.axis.title)) +
        theme(legend.title = element_blank(), legend.position=&amp;quot;top&amp;quot;,
              legend.direction=&amp;quot;horizontal&amp;quot;) +
        theme(legend.key.width=unit(1, &amp;quot;cm&amp;quot;), legend.key.height=unit(0.25, &amp;quot;cm&amp;quot;),
              legend.spacing = unit(-0.5,&amp;quot;cm&amp;quot;)) +
        theme(plot.title=element_text(colour=color.title, size = title_size)) +
        theme(plot.subtitle=element_text(colour=color.title, size = subtitle_size)) +
        theme(plot.caption=element_text(colour=color.title, size = caption_size)) +
        theme(axis.text.x=element_blank()) +
        theme(axis.text.y=element_blank()) +
        theme(axis.title.y=element_blank()) +
        theme(axis.title.x=element_blank()) +
        theme(strip.background = element_rect(fill=color.background,
                                              color=color.background),
              strip.text = element_text(colour=color.axis.title))
    
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;V. Ya casi estamos. Definimos un rango de transparencia, y de tamaño de los puntos que vamos a mapear. La idea es que en las coordenadas desde donde salen o llegan múltiples viajes sean representadas con puntos más grandes y brillantes. Yo elegí los parámetros en base a prueba y error, ajustando hasta que me gustaron los resultados:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;alpha_range = c(0.1, 0.8)
size_range = c(0.2, 0.4)&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34; style=&#34;list-style-type: upper-roman&#34;&gt;
&lt;li&gt;Todo listo para generar el mapa. Allá vamos!&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
   geom_polygon(data = calles,
               aes(x = long, y = lat, group = group),
             color = &amp;quot;grey10&amp;quot;, fill = NA) +
    geom_point(data = taxis_origenes,
               aes(x = lon, 
                   y = lat, 
                   alpha = n, 
                   size = n),
               color = &amp;quot;aquamarine&amp;quot;) +
    geom_point(data = taxis_destinos,
               aes(x = lon, 
                   y = lat, 
                   alpha = n, 
                   size = n),
               color = &amp;quot;indianred1&amp;quot;) +
    scale_alpha_continuous(range = alpha_range, 
                           trans = &amp;quot;log&amp;quot;, 
                           limits = range(taxis_origenes$n)) +
    scale_size_continuous(range = size_range, 
                          trans = &amp;quot;log&amp;quot;, 
                          limits = range(taxis_origenes$n)) +
    theme_ipsum_map_dark(base_size = 12, title_size = 18, 
                         subtitle_size = 12, caption_size = 10) +
    coord_map(xlim = range(taxis_origenes$lon), 
              ylim = range(taxis_origenes$lat)) +
    theme(legend.position=&amp;quot;none&amp;quot;) +
    labs(title=&amp;quot;Taxis en Buenos Aires: origen y destino de viajes&amp;quot;,
         subtitle = &amp;quot;Mayo - agosto 2017&amp;quot;,
         caption = &amp;quot;fuente: dataset BA Taxi - Datatón Smart City Expo Buenos Aires&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;que-curioso&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Qué curioso&lt;/h2&gt;
&lt;p&gt;He aquí la sorpresa. Al norte de la Ciudad, junto al río, aparece una notable aglomeración de taxis bajando pasajeros, pero casi ningún viaje se origina allí. Algo similar, en menor escala, ocurre en la esquina noreste de la Ciudad, cerca del puerto.&lt;/p&gt;
&lt;p&gt;Los que tenemos nuestra obsesión por temas de transporte enseguida reconocemos los lugares. Son el aeropuerto de la Ciudad (Aeroparque) y la principal estación de buses de larga distancia (Retiro).&lt;/p&gt;
&lt;p&gt;Podemos hacer de forma muy fácil un “zoom in” para verificarlo, usando el paquete &lt;em&gt;ggmaps&lt;/em&gt;, que permite descargar desde Google Maps un mapa de cualquier lugar nombrado.&lt;/p&gt;
&lt;p&gt;Invoquemos un mapa de “Aeroparque Buenos Aires”, con nuestra data superpuesta:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggmap)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;qmap(&amp;quot;Aeroparque Buenos Aires&amp;quot;, zoom = 14, color = &amp;quot;bw&amp;quot;, scale = 2) +  
    geom_point(data = taxis_origenes,
               aes(x = lon,
                   y = lat),
               alpha = 0.5,
               color = &amp;quot;darkgreen&amp;quot;) +
    geom_point(data = taxis_destinos,
               aes(x = lon, 
                   y = lat),
               alpha = 0.5,
               color = &amp;quot;indianred1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Confirmado, el “misterioso” aglutinamiento de llegadas sin salidas ocurre en Aeroparque.&lt;/p&gt;
&lt;p&gt;Ahora pidámosle a Google un mapa de “Estación de buses Retiro”:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;qmap(&amp;quot;Estación de buses Retiro, Buenos Aires&amp;quot;, zoom = 15, color = &amp;quot;bw&amp;quot;, scale = 2) +  
    geom_point(data = taxis_origenes,
               aes(x = lon,
                   y = lat),
               alpha = 0.5,
               color = &amp;quot;darkgreen&amp;quot;) +
    geom_point(data = taxis_destinos,
               aes(x = lon, 
                   y = lat),
               alpha = 0.5,
               color = &amp;quot;indianred1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Es la estación nomás!&lt;/p&gt;
&lt;p&gt;Vamos a la explicación. Por si alguno no lo sabía, es &lt;em&gt;vox populi&lt;/em&gt; que en Aeroparque y Retiro operan &lt;a href=&#34;http://www.lanacion.com.ar/2027084-nadie-controla-las-paradas-de-taxis-del-aeroparque-pese-a-las-denuncias-por-irregularidades&#34;&gt;grupos de taxistas confabulados&lt;/a&gt; que toman control del área para su uso exclusivo. Quienes pagan por el privilegio, pueden trabajar allí. Los taxistas que no forman parte del negocio e intentan llevarse pasajeros son amenazados o sometidos a violencia para dejar claro que la regla es férrea. Debido a la virtual ausencia de viajes vía BA Taxi que parten desde allí, podemos asumir que los taxistas que trabajan con la app ignoran (por su propio bien!) a los pasajeros que los convocan desde los territorios calientes. La abundancia de puntos rojos demuestra que los choferes de BA Taxi visitan seguido los sitios, dejando pasajeros, pero no se atreven a ir a buscarlos allí.&lt;/p&gt;
&lt;p&gt;Dicho esto, algunos puntitos verdes que asoman en ambos sitios sugieren el accionar de taxistas osados -o muy distraídos- que se han llevado pasajeros en las narices de la mafia.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;cuantificando-el-efecto-de-la-mafia-de-los-taxis&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Cuantificando el efecto de la mafia de los taxis&lt;/h2&gt;
&lt;p&gt;Podemos notar a a simple vista la presencia de territorios vedados. Pero cómo podemos encontrarlos analíticamente? Se puede definir un algoritmo que los detecte?&lt;/p&gt;
&lt;p&gt;Claro que sí. Hay muchas maneras de aproximarse a una solución, pero una fácil de explicar es así:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Dividimos la ciudad con una grilla que divida el espacio en áreas (celdas) iguales.&lt;/li&gt;
&lt;li&gt;En cada celda, medimos la proporción de viajes que llegan vs.. los que se originan allí&lt;/li&gt;
&lt;li&gt;Tomamos la distribución de tasas origen/destino e identificamos los casos anómalos, en particular los que ocurren en áreas de actividad intensa.&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&#34;dividimos-la-ciudad-con-una-grilla-que-particione-el-espacio-en-areas-celdas-iguales&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Dividimos la ciudad con una grilla que particione el espacio en áreas (celdas) iguales&lt;/h3&gt;
&lt;p&gt;Usamos el excelente paquete &lt;em&gt;sf&lt;/em&gt;, que ofrece una función para proyectar una grilla sobre la extensión de un set de datos georeferenciados.&lt;/p&gt;
&lt;p&gt;Para ello juntamos las salidas y llegadas que identificamos antes en un sólo dataset, y lo transformamos en un objeto espacial.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)

geo_data &amp;lt;- taxis_destinos %&amp;gt;% 
    bind_rows(taxis_origenes) %&amp;gt;% 
    st_as_sf(coords = c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;), crs = 4326)

plot(geo_data[&amp;quot;tipo&amp;quot;], col = c(&amp;quot;aquamarine&amp;quot;, &amp;quot;indianred1&amp;quot;), 
     key.pos = NULL, main = &amp;quot;salidas en verde, llegadas en rojo&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Se evidencia un pequeño problema: Existen varios viajes que terminan fuera de los límites de la Ciudad. Sólo nos interesan viajes dentro de sus fronteras, ya que fuera de ellas es natural que existan más llegadas que salidas, asumiendo que los pasajeros que hacen el camino inverso tenderán a utilizar servicios de taxi locales que no son registrados en el dataset de BA Taxi.&lt;/p&gt;
&lt;p&gt;No hay problema. Leemos el archivo que contiene los límites de los &lt;a href=&#34;https://data.buenosaires.gob.ar/dataset/barrios&#34;&gt;barrios de Buenos Aires&lt;/a&gt; (también cortesía de Buenos Aires Data) y lo “disolvemos” para que nos quede un sólo polígono que representa la superficie de la ciudad.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;limites_CABA &amp;lt;- st_read(&amp;#39;../data/barrios/barrios_badata.shp&amp;#39;) %&amp;gt;% 
    st_transform(4326) %&amp;gt;% 
    mutate(ciudad = &amp;quot;CABA&amp;quot;) %&amp;gt;% 
    group_by(ciudad) %&amp;gt;% 
    summarise()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Reading layer `barrios_badata&amp;#39; from data source `/home/havb/Dropbox/blog/content/data/barrios/barrios_badata.shp&amp;#39; using driver `ESRI Shapefile&amp;#39;
## Simple feature collection with 48 features and 4 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: 93743.42 ymin: 91566.42 xmax: 111752 ymax: 111285.1
## epsg (SRID):    NA
## proj4string:    +proj=tmerc +lat_0=-34.6297166 +lon_0=-58.4627 +k=0.9999980000000001 +x_0=100000 +y_0=100000 +ellps=intl +units=m +no_defs&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(limites_CABA)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ahora combinamos nuestra data de taxis con la silueta de la ciudad, y filtramos el resultado para descartar los puntos que cae fuera de los límites.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;geo_data &amp;lt;- geo_data %&amp;gt;% 
    st_join(limites_CABA) %&amp;gt;% 
    filter(ciudad == &amp;quot;CABA&amp;quot;)

plot(geo_data[&amp;quot;tipo&amp;quot;], col = c(&amp;quot;aquamarine&amp;quot;, &amp;quot;indianred1&amp;quot;), 
     key.pos = NULL, main = &amp;quot;salidas en verde, llegadas en rojo&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;720&#34; /&gt; &lt;em&gt;Voilà!&lt;/em&gt;. Ahora creamos la grilla…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;grilla &amp;lt;- geo_data %&amp;gt;% 
    st_make_grid(what = &amp;quot;polygons&amp;quot;, n = c(20, 20)) %&amp;gt;%
    st_sf() %&amp;gt;%
    mutate(ID = row_number()) 


plot(geo_data[&amp;quot;tipo&amp;quot;], col = c(&amp;quot;aquamarine&amp;quot;, &amp;quot;indianred1&amp;quot;), key.pos = NULL, main = NULL) 
plot(st_geometry(grilla), add = T)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;… y asociamos a cada par de coordenadas con la celda donde cae:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tasa_destino_origen &amp;lt;- geo_data %&amp;gt;% 
    st_join(grilla) %&amp;gt;% 
    group_by(ID) %&amp;gt;%
    summarise(total = n(), 
              tasa = sum(tipo == &amp;quot;destino&amp;quot;, na.rm = T) / 
                          sum(tipo == &amp;quot;origen&amp;quot;, na.rm = T))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;en-cada-celda-medimos-la-proporcion-de-viajes-que-llegan-vs.-los-que-se-originan-alli&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;En cada celda, medimos la proporción de viajes que llegan Vs. los que se originan allí&lt;/h3&gt;
&lt;p&gt;Esto se puede hacer en una sola cadena de funciones, con un &lt;em&gt;join&lt;/em&gt; espacial entre data de taxis y grilla, un agrupado por identificador de celda, y una cálculo a nivel celda de la relación cantidad de llegadas / cantidad de salidas&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tasa_destino_origen &amp;lt;- geo_data %&amp;gt;% 
    st_join(grilla) %&amp;gt;% 
    group_by(ID) %&amp;gt;%
    summarise(total = n(), 
              tasa = sum(tipo == &amp;quot;destino&amp;quot;, na.rm = T) / 
                sum(tipo == &amp;quot;origen&amp;quot;, na.rm = T)) %&amp;gt;% 
  # la condición &amp;quot;is.finite&amp;quot; elimina los casos donde hubo 0 salidas
  filter(is.finite(tasa))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;tomamos-la-distribucion-de-tasas-origendestino-e-identificamos-los-casos-anomalos&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Tomamos la distribución de tasas origen/destino e identificamos los casos anómalos&lt;/h3&gt;
&lt;p&gt;Antes de hacer cuentas, volvamos a anticipar los resultados con una visualización. Cómo se ve en el mapa la tasa origen/destino de cada zona de la ciudad?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(tasa_destino_origen[&amp;quot;tasa&amp;quot;], 
     main = &amp;quot;Viajes de BA Taxi por zona: cantidad de llegadas por cada salida&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Oh si, esto salió bien. Aeroparque brilla como material radioactivo. Retiro, si bien está lejos en intensidad, también se distingue de sus alrededores.&lt;/p&gt;
&lt;p&gt;Ahora si, los números. Filtremos la data para extraer las celdas donde la tasa es desproporcionada, eligiendo un piso (arbitrario) de 10 salidas por cada llegada.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;outliers &amp;lt;- tasa_destino_origen %&amp;gt;% 
  arrange(desc(tasa)) %&amp;gt;% 
  filter(tasa &amp;gt; 10) %&amp;gt;% 
  mutate(ID = as.factor(ID))

outliers&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 5 features and 3 fields
## geometry type:  MULTIPOINT
## dimension:      XY
## bbox:           xmin: -58.49042 ymin: -34.68928 xmax: -58.37098 ymax: -34.55538
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
## # A tibble: 5 x 4
##   ID    total  tasa                                               geometry
##   &amp;lt;fct&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;                                       &amp;lt;MULTIPOINT [°]&amp;gt;
## 1 353     357  88.2 (-58.41605 -34.55555, -58.41598 -34.55565, -58.41597 …
## 2 27       30  29.0 (-58.47032 -34.68344, -58.46803 -34.68928, -58.46793 …
## 3 96       26  25.0 (-58.38858 -34.65836, -58.38853 -34.6581, -58.38823 -…
## 4 277     215  22.9 (-58.37959 -34.59034, -58.37943 -34.59031, -58.37802 …
## 5 45       12  11.0 (-58.49042 -34.6756, -58.49033 -34.67566, -58.48972 -…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Son sólo cinco áreas, de las cuales dos registran una cantidad de viajes un orden de magnitud mayor a las demás: IDs 353 y 277, que -como podemos comprobar- corresponden en efecto a Aeroparque y Retiro:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(outliers[&amp;quot;ID&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-20-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;De éste modo hemos medido el efecto de la mafia en las zonas donde operan, al menos en lo que respecta a los viajes registrados por BA Taxi. En los alrededores de Aeroparque, la tasa es de 88,25: por cada 88 taxistas que terminan un viaje allí, apenas 2 logran llevarse pasajeros. En retiro, la tasa es de casi 23 llegadas por cada salida.&lt;/p&gt;
&lt;p&gt;Para ponerlo en perspectiva, el promedio de la ciudad es de 2,7:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean(tasa_destino_origen$tasa)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.732686&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En forma gráfica:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tasa_destino_origen %&amp;gt;% 
  mutate(media = mean(tasa)) %&amp;gt;% 
  ggplot() +
  geom_histogram(aes(tasa), bins = nrow(tasa_destino_origen)) +
  geom_vline(aes(xintercept = media), color = &amp;quot;blue&amp;quot;) +
  geom_vline(aes(xintercept = 88.25), color = &amp;quot;red&amp;quot;) +
  geom_vline(aes(xintercept = 22.89), color = &amp;quot;red&amp;quot;) +
  theme_ipsum() +
  labs(title = &amp;quot;Relación llegadas vs. salidas de taxis&amp;quot;,
       subtitle = &amp;quot;Sistema BA Taxi&amp;quot;,
       x = &amp;quot;taxis que llegan por cada uno que sale&amp;quot;) +
  geom_label(data = data.frame(x = c(mean(tasa_destino_origen$tasa), 22.89, 88.25),
                               y = rep(40, 3)),
             aes(x, y, label = c(&amp;quot;Media BA&amp;quot;, &amp;quot;Retiro&amp;quot;, &amp;quot;Aeroparque&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-13-taxis-en-buenos-aires-mapas-claros-y-negocios-turbios_files/figure-html/unnamed-chunk-22-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;por-ultimo-que-pasa-con-las-otras-tres-zonas-donde-los-taxis-dejan-pasajeros-pero-rara-vez-los-van-a-buscar&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Por último: qué pasa con las otras tres zonas donde los taxis dejan pasajeros pero rara vez los van a buscar?&lt;/h2&gt;
&lt;p&gt;Se trata de un fenómeno distinto, y que amerita un análisis aparte que por ahora no vamos a desarrollar. Las otras tres zonas donde encontramos una relación desproporcionada de llegadas vs. salidas se encuentran en el sur de la Ciudad.&lt;/p&gt;
&lt;p&gt;Es fácil superponer nuestra data sobre un mapa satelital, para jugar con el nivel de zoom e inspeccionar los alrededores:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(mapview)
mapview(st_geometry(outliers), map.types = c(&amp;quot;Esri.WorldImagery&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;htmlwidget-1&#34; style=&#34;width:720px;height:768px;&#34; class=&#34;leaflet html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-1&#34;&gt;{&#34;x&#34;:{&#34;options&#34;:{&#34;minZoom&#34;:1,&#34;maxZoom&#34;:100,&#34;crs&#34;:{&#34;crsClass&#34;:&#34;L.CRS.EPSG3857&#34;,&#34;code&#34;:null,&#34;proj4def&#34;:null,&#34;projectedBounds&#34;:null,&#34;options&#34;:{}},&#34;bounceAtZoomLimits&#34;:false,&#34;maxBounds&#34;:[[[-90,-370]],[[90,370]]]},&#34;calls&#34;:[{&#34;method&#34;:&#34;addProviderTiles&#34;,&#34;args&#34;:[&#34;Esri.WorldImagery&#34;,1,&#34;Esri.WorldImagery&#34;,{&#34;errorTileUrl&#34;:&#34;&#34;,&#34;noWrap&#34;:false,&#34;zIndex&#34;:null,&#34;unloadInvisibleTiles&#34;:null,&#34;updateWhenIdle&#34;:null,&#34;detectRetina&#34;:false,&#34;reuseTiles&#34;:false}]},{&#34;method&#34;:&#34;addCircleMarkers&#34;,&#34;args&#34;:[[-34.5555475,-34.5556513,-34.5556066,-34.555598,-34.5556049,-34.5555996,-34.5555912,-34.5556238,-34.5556024,-34.55563408,-34.5555924,-34.5555806,-34.5556048,-34.5555942,-34.5556051,-34.55566219,-34.55562662,-34.5555705,-34.5556216,-34.5555833,-34.5555828,-34.5556183,-34.5556209,-34.5556392,-34.55549298,-34.55558,-34.5556133,-34.5555783,-34.5555983,-34.5555748,-34.5556531,-34.5555167,-34.5555323,-34.5556234,-34.5555812,-34.5563458,-34.5556219,-34.5554839,-34.5555886,-34.5555561,-34.5555959,-34.5555905,-34.55550127,-34.5556027,-34.5556547,-34.5554477,-34.5555554,-34.5556363,-34.5554357,-34.5554889,-34.55550482,-34.555447,-34.5555794,-34.5554641,-34.5556164,-34.555593,-34.5557174,-34.5556459,-34.5556787,-34.5556936,-34.5556176,-34.5566079,-34.555725,-34.5553776,-34.5565823,-34.555959,-34.5561382,-34.55568684,-34.5558467,-34.5558053,-34.5557551,-34.5556841,-34.5560667,-34.5566458,-34.556323,-34.5555877,-34.5556568,-34.5558191,-34.5557376,-34.5557698,-34.5557454,-34.5561391,-34.55555625,-34.555902,-34.5557737,-34.5561692,-34.5555315,-34.5558521,-34.5560043,-34.5556103,-34.5557168,-34.5558247,-34.5558904,-34.5558825,-34.5556897,-34.5556229,-34.5560652,-34.5558309,-34.5558624,-34.5558918,-34.5557933,-34.5559643,-34.5561417,-34.55572565,-34.5557719,-34.5558236,-34.5564543,-34.5558101,-34.55584727,-34.5562743,-34.5556861,-34.555955,-34.5559438,-34.5560064,-34.5555897,-34.5559425,-34.556037,-34.5566801,-34.5558637,-34.5559849,-34.5558069,-34.5560295,-34.5561107,-34.5559764,-34.555871,-34.5560683,-34.5564483,-34.5563898,-34.55593193,-34.555985,-34.5558498,-34.556075,-34.5558981,-34.5558489,-34.5560037,-34.5563968,-34.5558727,-34.5558214,-34.5565644,-34.5559096,-34.5556852,-34.5557043,-34.55571,-34.555852,-34.5559803,-34.5560156,-34.5558595,-34.5560121,-34.555939,-34.5559449,-34.5558163,-34.5560734,-34.5561885,-34.55583504,-34.5559195,-34.5559416,-34.5557499,-34.5560066,-34.5558046,-34.5561292,-34.55601,-34.55615686,-34.5557709,-34.5561737,-34.5559219,-34.5558971,-34.55613374,-34.5561915,-34.5561931,-34.5558233,-34.5557539,-34.5557085,-34.556254,-34.5561761,-34.5561714,-34.55603245,-34.5559542,-34.5558065,-34.556171,-34.5559049,-34.5565974,-34.5559106,-34.5561569,-34.5561532,-34.5557145,-34.5560607,-34.5559082,-34.5560453,-34.5563395,-34.5561375,-34.5559085,-34.5564654,-34.556376,-34.5563821,-34.5559067,-34.55611096,-34.556252,-34.5558801,-34.5564474,-34.5558087,-34.5562739,-34.5557388,-34.5558525,-34.5558534,-34.5558863,-34.55607242,-34.556247,-34.5557356,-34.5559624,-34.5560768,-34.5561378,-34.5562456,-34.5561699,-34.55652665,-34.5558479,-34.5558132,-34.5558517,-34.5558723,-34.5558189,-34.5560493,-34.555944,-34.555952,-34.5563848,-34.5561809,-34.5558648,-34.555872,-34.5557482,-34.556335,-34.5559016,-34.5561058,-34.5561144,-34.5561573,-34.556295,-34.5559247,-34.5557422,-34.5562958,-34.5563137,-34.5559114,-34.5562991,-34.5559401,-34.5561611,-34.5558777,-34.5562943,-34.5559717,-34.5560529,-34.5559432,-34.5557983,-34.5558083,-34.5559708,-34.5559811,-34.5563269,-34.5559634,-34.5560089,-34.556685,-34.5560977,-34.5563383,-34.55626652,-34.5561224,-34.5562933,-34.5559862,-34.556056,-34.5562494,-34.5561152,-34.5558163,-34.55607338,-34.5562003,-34.5565354,-34.5568861,-34.5564549,-34.5559602,-34.5571719,-34.5565486,-34.55611632,-34.5560951,-34.5563896,-34.55595283,-34.5564319,-34.5561982,-34.5561202,-34.5559694,-34.5560127,-34.5559605,-34.5560956,-34.5561464,-34.5561743,-34.5563284,-34.5563681,-34.5562567,-34.5563627,-34.5560228,-34.55627787,-34.5559941,-34.5562986,-34.5564782,-34.5564108,-34.5566961,-34.556388,-34.55633854,-34.5563207,-34.5560746,-34.5563781,-34.5564132,-34.55647105,-34.5563038,-34.5567389,-34.5562674,-34.55626,-34.5563157,-34.5562375,-34.5567263,-34.5564618,-34.556755,-34.5565859,-34.55662,-34.5566883,-34.5566562,-34.5568122,-34.5568782,-34.55674,-34.5567416,-34.5565858,-34.5570031,-34.5570059,-34.5570887,-34.5570151,-34.5568038,-34.5570395,-34.5569242,-34.55705,-34.5572235,-34.5572888,-34.557111,-34.5579853,-34.5573457,-34.5574315,-34.5573949,-34.5573386,-34.5573489,-34.55744093,-34.5571748,-34.5572451,-34.5572432,-34.55726777,-34.557349,-34.5571754,-34.5573175,-34.557322,-34.5577869,-34.557364,-34.5574279,-34.5578154,-34.5578687,-34.5579733,-34.55775,-34.5580643,-34.557975,-34.6834352,-34.6892756,-34.684129,-34.68193186,-34.6822261,-34.6827396,-34.6830309,-34.6831133,-34.682975,-34.6832312,-34.6829633,-34.6834643,-34.6831101,-34.6836062,-34.6836674,-34.6836175,-34.6835925,-34.6834122,-34.683647,-34.6836271,-34.68362552,-34.6837449,-34.68380516,-34.6839017,-34.6838396,-34.68361398,-34.6837571,-34.6834695,-34.6835516,-34.6583606,-34.6581029,-34.6581801,-34.656839,-34.6568345,-34.6568126,-34.6569188,-34.6568689,-34.6568681,-34.65690628,-34.6568915,-34.656881,-34.65685268,-34.6568783,-34.656875,-34.6568618,-34.6568791,-34.6568164,-34.6568477,-34.6568706,-34.6568409,-34.6568727,-34.6568212,-34.6568816,-34.6568039,-34.6568325,-34.5903405,-34.5903118,-34.5911414,-34.5852862,-34.5855079,-34.585578,-34.5855456,-34.5852343,-34.585354,-34.5853871,-34.5850712,-34.58575009,-34.5848467,-34.5858446,-34.5858414,-34.5856708,-34.585685,-34.5856864,-34.5857542,-34.5856933,-34.5856283,-34.5858218,-34.5868342,-34.58610164,-34.5861793,-34.5859367,-34.5860089,-34.5860013,-34.591299,-34.5859709,-34.5860179,-34.5859607,-34.585994,-34.5860126,-34.5859952,-34.5860753,-34.5860399,-34.5860829,-34.5860543,-34.58610128,-34.5860724,-34.5860701,-34.5908518,-34.5908324,-34.5860596,-34.586498,-34.5860711,-34.5860629,-34.5861171,-34.58613708,-34.5848934,-34.5908385,-34.5863924,-34.59128686,-34.5861733,-34.586195,-34.5861851,-34.5912012,-34.5911263,-34.5911086,-34.5862857,-34.5863771,-34.5862571,-34.5863559,-34.5864061,-34.5862797,-34.5863075,-34.5863147,-34.5863076,-34.5863223,-34.58629363,-34.5910461,-34.5863346,-34.58630241,-34.5863189,-34.58509096,-34.5863764,-34.5863547,-34.5863406,-34.5862885,-34.5863166,-34.5863,-34.5863833,-34.5863783,-34.5863132,-34.58637284,-34.5863457,-34.5863625,-34.5862887,-34.5863718,-34.5863093,-34.58635,-34.5864005,-34.58636313,-34.5863813,-34.58633843,-34.58636211,-34.5864142,-34.5864008,-34.5864469,-34.5863993,-34.5864228,-34.5865056,-34.58649,-34.5870327,-34.5865039,-34.5865616,-34.5865794,-34.5865617,-34.5866067,-34.5911814,-34.5833219,-34.5865796,-34.58668343,-34.5866575,-34.58662424,-34.5866704,-34.5912002,-34.5866196,-34.5866901,-34.5867196,-34.5866931,-34.5866615,-34.5866646,-34.5866671,-34.5866827,-34.5866379,-34.5867504,-34.5866587,-34.5866684,-34.5867134,-34.5867023,-34.5866688,-34.5867091,-34.5866886,-34.5866795,-34.5867033,-34.58669492,-34.5874492,-34.58670642,-34.5867047,-34.58546566,-34.5867472,-34.5867062,-34.5867493,-34.586661,-34.58667107,-34.58672615,-34.5867771,-34.5867923,-34.586815,-34.5866926,-34.58640635,-34.5868233,-34.5867897,-34.5868296,-34.58691138,-34.5868051,-34.5870347,-34.5905224,-34.5903309,-34.586932,-34.5897741,-34.5869491,-34.5869576,-34.5912329,-34.5869186,-34.5841336,-34.5869118,-34.58696696,-34.5869974,-34.5869714,-34.58701,-34.5870423,-34.5870121,-34.5870043,-34.5870041,-34.5870437,-34.58697686,-34.5869795,-34.5869896,-34.5870596,-34.5869982,-34.5870445,-34.5870038,-34.5870233,-34.5871917,-34.58709376,-34.5902594,-34.5868804,-34.5870756,-34.5876659,-34.5871206,-34.586195,-34.5873972,-34.587007,-34.588584,-34.5890104,-34.5885921,-34.586934,-34.5908334,-34.5908251,-34.5890036,-34.5877091,-34.5884165,-34.59078012,-34.5883204,-34.5871279,-34.5882929,-34.587051,-34.5869373,-34.587108,-34.5855233,-34.5897442,-34.589385,-34.675605,-34.6756594,-34.676055,-34.6763215,-34.6765488,-34.6763661,-34.6766457,-34.6765,-34.6765357,-34.6766432,-34.678144,-34.677302],[-58.4160476,-58.4159834,-58.4159748,-58.4159681,-58.415959,-58.4159218,-58.4159205,-58.4159185,-58.4159147,-58.4159079,-58.415889,-58.4158869,-58.4158714,-58.415867,-58.4158647,-58.41585684,-58.41585664,-58.4158466,-58.415836,-58.4158201,-58.41581777,-58.415815,-58.4158118,-58.415796,-58.41579206,-58.41578,-58.4157767,-58.4157667,-58.4157648,-58.4157563,-58.4157516,-58.4157495,-58.415744,-58.4157327,-58.4157319,-58.4157307,-58.415724,-58.415713,-58.4157078,-58.4156998,-58.4156992,-58.4156828,-58.41566157,-58.4156528,-58.4156508,-58.415643,-58.4156387,-58.415617,-58.4156082,-58.4156078,-58.41558036,-58.4154996,-58.4154459,-58.4154409,-58.4154013,-58.4153874,-58.4153168,-58.4152945,-58.4152919,-58.4152294,-58.4152087,-58.4151511,-58.4151225,-58.4151191,-58.415062,-58.415062,-58.4150519,-58.41503812,-58.4150083,-58.4150049,-58.41499483,-58.4149798,-58.4149783,-58.41497779,-58.4149728,-58.4149686,-58.4149435,-58.4149357,-58.4149258,-58.4149141,-58.4148972,-58.4148962,-58.41488555,-58.4148719,-58.4148603,-58.4148404,-58.4148279,-58.4148126,-58.4148056,-58.4147858,-58.4147778,-58.4147729,-58.4147479,-58.4147374,-58.4147267,-58.4147053,-58.41469,-58.4146893,-58.414683,-58.4146733,-58.4146633,-58.4146547,-58.4146517,-58.41464349,-58.4146325,-58.4146204,-58.4146161,-58.4146118,-58.41460445,-58.4146032,-58.4145934,-58.41459,-58.4145886,-58.4145827,-58.4145827,-58.414576,-58.4145722,-58.4145671,-58.4145604,-58.4145581,-58.4145529,-58.4145506,-58.4145485,-58.4145397,-58.4145334,-58.4145233,-58.4144935,-58.4144935,-58.4144927,-58.4144917,-58.4144853,-58.414485,-58.4144847,-58.4144809,-58.4144789,-58.4144767,-58.4144739,-58.4144669,-58.4144629,-58.4144626,-58.4144601,-58.4144552,-58.4144495,-58.4144468,-58.4144412,-58.414439,-58.4144323,-58.4144322,-58.4144304,-58.4144276,-58.4144229,-58.4144147,-58.4144128,-58.4144123,-58.4144116,-58.4144112,-58.4144112,-58.4144109,-58.4144097,-58.4144088,-58.4144083,-58.41440358,-58.4144027,-58.4143996,-58.4143888,-58.4143774,-58.41437629,-58.4143751,-58.4143723,-58.414365,-58.4143643,-58.4143643,-58.4143598,-58.4143598,-58.414356,-58.41435113,-58.414351,-58.4143482,-58.414348,-58.4143465,-58.4143398,-58.4143398,-58.414333,-58.4143301,-58.4143299,-58.414329,-58.4143282,-58.4143265,-58.414317,-58.4143149,-58.4143046,-58.4142996,-58.4142967,-58.4142935,-58.4142916,-58.41428465,-58.4142699,-58.4142689,-58.4142658,-58.4142652,-58.4142595,-58.4142571,-58.4142543,-58.4142515,-58.4142481,-58.41423336,-58.414233,-58.4142252,-58.4142208,-58.4142194,-58.4142125,-58.4141995,-58.414198,-58.41417859,-58.414178,-58.4141742,-58.4141686,-58.4141561,-58.4141553,-58.4141545,-58.4141481,-58.4141422,-58.4141369,-58.4141327,-58.4141288,-58.4141146,-58.4140867,-58.4140817,-58.4140811,-58.41408,-58.4140787,-58.4140781,-58.4140658,-58.4140649,-58.4140618,-58.4140602,-58.4140588,-58.4140571,-58.4140547,-58.4140451,-58.4140422,-58.4140373,-58.4140254,-58.4140246,-58.4140222,-58.4140188,-58.41401629,-58.4140135,-58.4140045,-58.4140032,-58.4140031,-58.413992,-58.4139862,-58.413976,-58.4139741,-58.4139717,-58.41396779,-58.4139622,-58.4139567,-58.413951,-58.4139192,-58.4139028,-58.4138913,-58.4138876,-58.41386154,-58.4138157,-58.4138136,-58.4137802,-58.413775,-58.4137589,-58.4137579,-58.4137579,-58.41375374,-58.413752,-58.4137315,-58.41372729,-58.4137245,-58.4137245,-58.4137245,-58.4137089,-58.413702,-58.4136932,-58.4136803,-58.4136799,-58.4136735,-58.4136353,-58.4136309,-58.4136291,-58.4136143,-58.4136094,-58.41358887,-58.4135854,-58.4135733,-58.4135367,-58.4135184,-58.4135102,-58.4134939,-58.41349314,-58.4134916,-58.4134748,-58.4134483,-58.413448,-58.41328308,-58.4132786,-58.4132675,-58.4132541,-58.4132183,-58.4132011,-58.4131865,-58.413156,-58.4131278,-58.413115,-58.4130927,-58.4128983,-58.412895,-58.4128045,-58.4127771,-58.4127738,-58.4127733,-58.4127713,-58.4125921,-58.4125592,-58.4125242,-58.4123916,-58.4123215,-58.412297,-58.4122825,-58.4122618,-58.4120817,-58.4120687,-58.4120591,-58.412,-58.4119536,-58.411893,-58.411829,-58.4118086,-58.4117756,-58.4117685,-58.41172989,-58.4117229,-58.4117154,-58.4116387,-58.41161008,-58.4115841,-58.4115798,-58.4115375,-58.4114999,-58.4114616,-58.411382,-58.4112931,-58.4112886,-58.4111657,-58.411,-58.410959,-58.4109199,-58.410799,-58.4703196,-58.4680346,-58.4679344,-58.4665881,-58.4662611,-58.4657583,-58.4657507,-58.4656533,-58.465543,-58.4655086,-58.4654741,-58.4654268,-58.4653997,-58.46536,-58.4653565,-58.4653187,-58.4652946,-58.4652884,-58.4652663,-58.4652492,-58.46524629,-58.4652209,-58.46521817,-58.4652152,-58.4652073,-58.4652064,-58.465144,-58.4650525,-58.4650029,-58.3885823,-58.3885335,-58.3882257,-58.3873157,-58.3872005,-58.387107,-58.3871051,-58.3870925,-58.3870902,-58.38708566,-58.3870836,-58.387083,-58.38707566,-58.3870633,-58.3870533,-58.3870429,-58.3870394,-58.3870339,-58.3870257,-58.3870161,-58.3870121,-58.3869944,-58.3869897,-58.3869778,-58.3869769,-58.386967,-58.3795862,-58.3794252,-58.3780198,-58.3760798,-58.375941,-58.3758173,-58.375791,-58.375666,-58.375655,-58.3756482,-58.3755236,-58.37537606,-58.3753717,-58.3753359,-58.3752841,-58.3752624,-58.3752267,-58.3752126,-58.3751335,-58.3750917,-58.3750739,-58.37494,-58.3749102,-58.37483526,-58.3747987,-58.3747447,-58.3747088,-58.3747083,-58.3746985,-58.3746925,-58.374689,-58.3746851,-58.3746566,-58.3746416,-58.374637,-58.37462,-58.374616,-58.3745822,-58.3745816,-58.37456361,-58.3745428,-58.3745384,-58.3745313,-58.3745313,-58.3745311,-58.374529,-58.37452,-58.3745044,-58.3745008,-58.37447535,-58.3744536,-58.3744307,-58.374367,-58.37433828,-58.374315,-58.37429,-58.3742579,-58.3742514,-58.3742119,-58.374201,-58.3741874,-58.3741819,-58.3741725,-58.3741654,-58.3741645,-58.3741604,-58.3741513,-58.3741463,-58.3741402,-58.3741356,-58.3741344,-58.3741318,-58.3741215,-58.37411616,-58.3741143,-58.37411199,-58.374109,-58.3741009,-58.3740972,-58.3740939,-58.3740906,-58.37409,-58.3740883,-58.3740883,-58.3740876,-58.37408759,-58.3740736,-58.3740594,-58.3740524,-58.3740515,-58.3740472,-58.3740466,-58.3740268,-58.37401605,-58.374009,-58.37400337,-58.37400223,-58.3739515,-58.3739348,-58.3739009,-58.3738936,-58.3738777,-58.3738721,-58.3738067,-58.3737737,-58.3736936,-58.3736927,-58.3736664,-58.373645,-58.3736187,-58.3736114,-58.3735954,-58.3735907,-58.3735882,-58.373567,-58.3735664,-58.3735659,-58.3735623,-58.3735435,-58.3735322,-58.3735269,-58.3735146,-58.3735113,-58.3735078,-58.3735067,-58.3734983,-58.3734958,-58.3734744,-58.3734733,-58.3734719,-58.3734713,-58.3734694,-58.3734647,-58.3734481,-58.3734476,-58.3734397,-58.3734367,-58.37343221,-58.3734283,-58.37340695,-58.3734038,-58.37340195,-58.3733958,-58.3733863,-58.3733785,-58.3733738,-58.37336299,-58.37336223,-58.3733083,-58.373306,-58.3732983,-58.373298,-58.37326904,-58.3732514,-58.3732507,-58.3732326,-58.37322103,-58.3732108,-58.3732054,-58.3731861,-58.3731609,-58.3730707,-58.3730299,-58.3730278,-58.3730158,-58.3730045,-58.3729982,-58.3729928,-58.3729915,-58.37293764,-58.3729308,-58.3729246,-58.3729074,-58.3728987,-58.3728973,-58.3728946,-58.3728875,-58.3728857,-58.37288404,-58.3728839,-58.3728768,-58.3728643,-58.3728596,-58.3728486,-58.3728283,-58.37281,-58.3728043,-58.3727904,-58.3727762,-58.3727709,-58.3727631,-58.3726595,-58.3725857,-58.372495,-58.3724725,-58.372331,-58.3722327,-58.3722249,-58.3721863,-58.3721623,-58.372162,-58.3721149,-58.3721138,-58.3720715,-58.3720477,-58.37201792,-58.3719981,-58.3719592,-58.3719482,-58.3715842,-58.3715415,-58.3712244,-58.3711331,-58.3710997,-58.3709847,-58.490416,-58.4903297,-58.489724,-58.4895413,-58.4894855,-58.4894729,-58.4892852,-58.489255,-58.4892219,-58.489063,-58.4880245,-58.484981],6,null,&#34;st_geometry(outliers)&#34;,{&#34;lineCap&#34;:null,&#34;lineJoin&#34;:null,&#34;clickable&#34;:true,&#34;pointerEvents&#34;:null,&#34;className&#34;:&#34;&#34;,&#34;stroke&#34;:true,&#34;color&#34;:&#34;#333333&#34;,&#34;weight&#34;:2,&#34;opacity&#34;:0.9,&#34;fill&#34;:true,&#34;fillColor&#34;:&#34;#6666ff&#34;,&#34;fillOpacity&#34;:0.6,&#34;dashArray&#34;:null},null,null,null,{&#34;maxWidth&#34;:800,&#34;minWidth&#34;:50,&#34;maxHeight&#34;:null,&#34;autoPan&#34;:true,&#34;keepInView&#34;:false,&#34;closeButton&#34;:true,&#34;zoomAnimation&#34;:true,&#34;closeOnClick&#34;:true,&#34;className&#34;:&#34;&#34;},[&#34;1&#34;,&#34;2&#34;,&#34;3&#34;,&#34;4&#34;,&#34;5&#34;],null,null]},{&#34;method&#34;:&#34;addScaleBar&#34;,&#34;args&#34;:[{&#34;maxWidth&#34;:100,&#34;metric&#34;:true,&#34;imperial&#34;:true,&#34;updateWhenIdle&#34;:true,&#34;position&#34;:&#34;bottomleft&#34;}]},{&#34;method&#34;:&#34;addHomeButton&#34;,&#34;args&#34;:[-58.490416,-34.6892756,-58.3709847,-34.5553776,&#34;Zoom to st_geometry(outliers)&#34;,&#34;&lt;strong&gt; st_geometry(outliers) &lt;\/strong&gt;&#34;,&#34;bottomright&#34;]},{&#34;method&#34;:&#34;addLayersControl&#34;,&#34;args&#34;:[&#34;Esri.WorldImagery&#34;,&#34;st_geometry(outliers)&#34;,{&#34;collapsed&#34;:true,&#34;autoZIndex&#34;:true,&#34;position&#34;:&#34;topleft&#34;}]}],&#34;limits&#34;:{&#34;lat&#34;:[-34.6892756,-34.5553776],&#34;lng&#34;:[-58.490416,-58.3709847]}},&#34;evals&#34;:[],&#34;jsHooks&#34;:{&#34;render&#34;:[{&#34;code&#34;:&#34;function(el, x, data) {\n  return (\nfunction(el, x, data) {\n\n  // get the leaflet map\n  var map = this; //HTMLWidgets.find(&#39;#&#39; + el.id);\n\n  // we need a new div element because we have to handle\n  // the mouseover output separately\n  // debugger;\n  function addElement () {\n    // generate new div Element\n    var newDiv = $(document.createElement(&#39;div&#39;));\n    // append at end of leaflet htmlwidget container\n    $(el).append(newDiv);\n    //provide ID and style\n    newDiv.addClass(&#39;lnlt&#39;);\n    newDiv.css({\n      &#39;position&#39;: &#39;relative&#39;,\n      &#39;bottomleft&#39;:  &#39;0px&#39;,\n      &#39;background-color&#39;: &#39;rgba(255, 255, 255, 0.7)&#39;,\n      &#39;box-shadow&#39;: &#39;0 0 2px #bbb&#39;,\n      &#39;background-clip&#39;: &#39;padding-box&#39;,\n      &#39;margin&#39;: &#39;0&#39;,\n      &#39;padding-left&#39;: &#39;5px&#39;,\n      &#39;color&#39;: &#39;#333&#39;,\n      &#39;font&#39;: &#39;9px/1.5 \&#34;Helvetica Neue\&#34;, Arial, Helvetica, sans-serif&#39;,\n    });\n    return newDiv;\n  }\n\n  // check for already existing lnlt class to not duplicate\n  var lnlt = $(el).find(&#39;.lnlt&#39;);\n  if(!lnlt.length) {\n    lnlt = addElement();\n\n    // grab the special div we generated in the beginning\n    // and put the mousmove output there\n    map.on(&#39;mousemove&#39;, function (e) {\n      lnlt.text(\n      &#39; x: &#39; + L.CRS.EPSG3857.project(e.latlng).x.toFixed(0) +\n      &#39; | y: &#39; + L.CRS.EPSG3857.project(e.latlng).y.toFixed(0) +\n      &#39; | epsg: 3857 &#39; +\n      &#39; | proj4: +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs &#39; +\n      &#39; | lon: &#39; + (e.latlng.lng).toFixed(5) +\n      &#39; | lat: &#39; + (e.latlng.lat).toFixed(5) +\n      &#39; | zoom: &#39; + map.getZoom() + &#39; &#39;);\n    })\n  };\n}\n).call(this.getMap(), el, x, data);\n}&#34;,&#34;data&#34;:null}]}}&lt;/script&gt;
&lt;p&gt;Según mi lectura, una de las celdas coincide con un área industrial. Las dos restantes con complejos habitacionales de vivienda pública.&lt;/p&gt;
&lt;p&gt;Se me ocurre una hipótesis cuya verificación quedará pendiente: ¿Será que los choferes de BA Taxi evitan viajes con origen en éstas zonas por temor, en la práctica discriminando a esos usuarios? En ese caso, la cantidad de viajes que &lt;em&gt;terminan&lt;/em&gt; allí se explicaría porque los taxistas inician el viaje en algún otro barrio, sin saber el destino hasta que el usuario está a bordo.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;RIP Dirección Provincial de Innovación Ciudadana: &lt;a href=&#34;http://poderciudadano.org/preocupacion-por-cambios-en-la-politica-de-gobierno-abierto-en-la-provincia-de-buenos-aires/&#34; class=&#34;uri&#34;&gt;http://poderciudadano.org/preocupacion-por-cambios-en-la-politica-de-gobierno-abierto-en-la-provincia-de-buenos-aires/&lt;/a&gt;&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Analizando data de Airbnb en Buenos Aires</title>
      <link>/post/analizando-data-de-airbnb-en-buenos-aires/</link>
      <pubDate>Sat, 09 Sep 2017 00:00:00 +0000</pubDate>
      <author>avazquez@gmail.com (H. Antonio Vazquez Brust)</author>
      <guid>/post/analizando-data-de-airbnb-en-buenos-aires/</guid>
      <description>&lt;p&gt;¡Airbnb! La plataforma de alquileres temporarios que aflije a &lt;a href=&#34;https://www.elconfidencial.com/vivienda/2017-05-14/turistificacion-alquiler-turistico-madrid-barcelona-valencia-airbnb-homeaway-rentalia-gentrificacion_1382367/&#34;&gt;autoridades municipales&lt;/a&gt; por &lt;a href=&#34;https://www.nytimes.com/roomfordebate/2015/06/16/san-francisco-and-new-york-weigh-airbnbs-effect-on-rent/airbnb-is-a-problem-for-cities-like-new-york-and-san-francisco&#34;&gt;doquier&lt;/a&gt;, formando junto a Uber la bestia de dos cabezas del &lt;a href=&#34;https://www.clarin.com/economia/economia/capitalismo-plataforma_0_ByIlCwtv7g.html&#34;&gt;capitalismo de platforma&lt;/a&gt;. Hasta hace unos años, en aquella era de inocencia, le llamábamos &lt;em&gt;the sharing economy&lt;/em&gt;. Pero la ilusión de que al usar la plataforma estamos participando de algún acto sublime de compartir entre pares se ha esfumado, al punto que desde una de esas revistas “para hombres” se anuncia con soltura que cuando uno usa Airbnb en verdad está &lt;a href=&#34;http://www.revistagq.com/noticias/articulos/turistificacion-airbnb/25908&#34;&gt;matando una ciudad que ama&lt;/a&gt;. Debo confesar que me he alojado en múltiples ocasiones mediante Airbnb, así que si tal cosa fuera cierta me corresponde una porción de la culpa.&lt;/p&gt;
&lt;p&gt;¿Cómo llegamos a éste punto? Los detractores de Airbnb acusan a la empresa de convertir los barrios residenciales en centros hoteleros semi-clandestinos, donde las viviendas disponibles desaparecen del mercado -convertidas en rentables alquileres temporarios- y los turistas desplazan a los vecinos de vieja data, quienes ya no encuentran o no pueden costear un alquiler permanente. La industria hotelera tampoco esta contenta, por obvias razones. Y los gobiernos municipales, con su crónica escasez de fondos, se rebelan ante el crecimiento de una actividad económica que aprovecha los bienes públicos de una ciudad (su historia, su estilo, su ambiente, sus servicios) evadiendo retribuir impuestos para mantener esos mismos recursos que explota.&lt;/p&gt;
&lt;p&gt;Airbnb, por su parte, asegura que su presencia es beneficiosa para las ciudades donde opera. En su momento promovía una imagen de conexión entre individuos, alimentando la idea de que las transacciones se llevaban a cabo entre viajeros comprometidos con “vivir la experiencia local” (no meros turistas) y anfitriones que los recibían en su hogar para convivir e intercambiar cultura. Hoy en día ha abandonado esa premisa, y si bien aún menciona lo de vivir la experiencia como un local, ya no pone tanto el foco en la convivencia sino en el destino. ¿Será porque el servicio está acaparado por rentistas que ofrecen propiedades donde no vive nadie excepto los clientes que trae Airbnb?&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/img/airbnb_destino.png&#34; alt=&#34;Los destinos resaltados en airbnb.com&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Los destinos resaltados en airbnb.com&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Podemos intentar responder a esa pregunta. Vamos a scrapear anuncios de Airbnb en Buenos Aires, y analizar lo hallado en busca de indicios. Recopilar información sobre los alojamientos publicados por la plataforma no es fácil, merced del diseño que hace muy trabajoso barrer en forma sistemática su sitio web. Por suerte tenemos a &lt;a href=&#34;http://tomslee.net/&#34;&gt;Tom Slee&lt;/a&gt;, quien acumula desde hace años información sobre la cantidad total de &lt;a href=&#34;http://tomslee.net/airbnb-data-collection-get-the-data&#34;&gt;alojamientos ofrecidos por Airbnb en ciudades de todo el mundo&lt;/a&gt;. Y no sólo comparte sus resultados, también ofrece el &lt;a href=&#34;https://github.com/tomslee/airbnb-data-collection/&#34;&gt;código en Python que utiliza para hacer el scraping&lt;/a&gt; - ¡Gracias Tom!. Usando sus scripts, pude acceder a un listado a priori completo de la oferta de Airbnb en Buenos Aires a mediados de julio del 2017. Contiene 9923 alojamientos:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
airba_df &amp;lt;- read_csv(&amp;#39;/home/havb/data/airbnb/Airbnb_listings_Buenos_Aires_July_2017.csv&amp;#39;)

nrow(airba_df)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 9923&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Muy bien! Es hora de interrogar amablemente a nuestra data. Cómo primer paso, vamos extraer un set de datos derivado con indicadores a nivel usuario, para calcular cuantos alojamientos ofrece cada uno, de qué tipo, y -lo más difícil de discernir- cuantos ingresos le ha generado su actividad en la plataforma. Para ésto último me guío, una vez más, por la experiencia de Tom Slee. Basándose en declaraciones que ha hecho aquí y allá la propia empresa, Tom estima que la cantidad de calificaciones que ha recibido un usuario (un dato que conocemos) representa un 55% del total de veces que ha recibido visitantes. Resta estimar cuantas noches y cuantos huéspedes representa, en promedio, cada transacción. Aquí asumo lo siguiente: el promedio de estadía es de cuatro noches, y el promedio de ocupación es la mitad de la capacidad total, redondeando hacia arriba (es decir, si la capacidad máxima es 3 o 4, asumo para ambos casos un promedio de dos huéspedes alojados por transaccción). Para los alojamientos con capacidad de más de 6 personas, asumo que no se cobra extra por los huéspedes arriba de 6.&lt;/p&gt;
&lt;p&gt;Si alguien tiene en mente parametros de estimación de ingresos que podrían ser mas acertados, me avisa y los ponemos en práctica! Mientras tanto:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Estimaciones tomadas respetuosamente de aquí: 
# http://tomslee.net/airbnb-data-collection-methodology-and-accuracy
usuarios &amp;lt;- airba_df %&amp;gt;%
  mutate(ingresos_estimados = (reviews / 0.55) * 
           price * 
           4 * 
           ifelse(accommodates &amp;lt; 6, (ceiling(accommodates / 2)), 3)) %&amp;gt;%
  group_by(host_id) %&amp;gt;%
  summarise(
    alojamientos = n(),
    dormitorios_totales = sum(bedrooms),
    ingresos_estimados = sum(ingresos_estimados),
    habitaciones_privadas = sum(room_type == &amp;quot;Private room&amp;quot;),
    propiedades_completas = sum(room_type == &amp;quot;Entire home/apt&amp;quot;),
    habitaciones_compartidas = sum(room_type == &amp;quot;Shared room&amp;quot;)    
  ) %&amp;gt;% 
  mutate(categoria_ingresos = case_when(percent_rank(ingresos_estimados) &amp;gt; .99 ~ &amp;quot;top 1 %&amp;quot;, 
                                        percent_rank(ingresos_estimados) &amp;gt; .9 ~ &amp;quot;top 2% a 10%&amp;quot;,
                                        TRUE ~ &amp;quot;resto&amp;quot;),
         categoria_alojamientos = case_when(.$alojamientos == 1 ~ &amp;quot;1&amp;quot;,
                                            .$alojamientos == 2 ~ &amp;quot;2&amp;quot;,
                                            .$alojamientos == 3 ~ &amp;quot;3&amp;quot;,
                                            .$alojamientos == 4 ~ &amp;quot;4&amp;quot;,
                                            .$alojamientos &amp;gt; 10 ~ &amp;quot;Más de 10&amp;quot;,
                                            .$alojamientos &amp;gt; 4 ~ &amp;quot;5 a 10&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora si, veamos los resultados.&lt;/p&gt;
&lt;div id=&#34;capacidad-total-y-distribucion-de-las-plazas-ofrecidas&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1. Capacidad total y distribución de las plazas ofrecidas&lt;/h2&gt;
&lt;p&gt;Cuanta gente podría dormir en Buenos Aires si todos los alojamientos publicados por Airbnb se colmaran?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(hrbrthemes)

airba_df %&amp;gt;% 
  count(accommodates) %&amp;gt;% 
  mutate(pct = n / sum(n)) %&amp;gt;% 
  ggplot(aes(factor(accommodates), pct)) + 
  geom_col(fill = &amp;quot;salmon&amp;quot;) + 
  scale_y_percent() +
  theme_ipsum(grid = &amp;quot;Y&amp;quot;) +
  labs(title = &amp;quot;Capacidad&amp;quot;,
       subtitle= paste(&amp;quot;Alojamientos publicados:&amp;quot;, nrow(airba_df), 
                       &amp;quot;\nPlazas totales:&amp;quot;, sum(airba_df$accommodates)),
       y = &amp;quot;alojamientos&amp;quot;,
       x = &amp;quot;capacidad máxima (huéspedes)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-09-analizando-data-de-airbnb-en-buenos-aires_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Según lo capturado en julio del 2017, quienes ofertan por Airbnb ofrecen una capacidad combinada de 27635 plazas. Más del 40$ de los anfitriones ofrecen alojamiento para dos personas. Las 4, 3 y una plaza siguen en popularidad, aunque de lejos. Un porcentaje muy bajo de alojamientos ofrece capacidad para ás de 6 persosnas, aunque hay ejemplos de hasta 16 plazas. Aquí imperan los departamentos, por más que haya en oferta lo que asumo han de ser algunas casonas.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;cantidad-y-tipo-de-alojamientos-ofrecidos-por-anfitrion&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2. Cantidad y tipo de alojamientos ofrecidos por anfitrión&lt;/h2&gt;
&lt;p&gt;Cuantos usuarios ofrecen alojamientos en la plataforma? Que tan común es que se ofrezcan múltiples alojamientos desde uns misma cuenta?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;usuarios %&amp;gt;%
  mutate(propiedad_compartida = ifelse(( habitaciones_privadas),
                                       &amp;quot;si&amp;quot;,
                                       &amp;quot;no&amp;quot;)) %&amp;gt;% 
  count(categoria_alojamientos, propiedad_compartida) %&amp;gt;% 
  ungroup() %&amp;gt;% 
  mutate(pct = n / sum(n)) %&amp;gt;% 
  ggplot(aes(factor(categoria_alojamientos), pct)) + 
  geom_col(aes(fill = propiedad_compartida)) + 
  scale_y_percent() +
  theme_ipsum(grid = &amp;quot;Y&amp;quot;) +
  labs(title = &amp;quot;Total de alojamientos ofrecidos por usuario&amp;quot;,
       fill = &amp;quot;Alguna\npropiedad\ncompartida&amp;quot;,
       subtitle= paste(&amp;quot;Total de anfitriones:&amp;quot;, nrow(usuarios)),
       y = &amp;quot;anfitriones&amp;quot;,
       x = &amp;quot;alojamientos publicados&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-09-analizando-data-de-airbnb-en-buenos-aires_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Este gráfico es el que muestra porqué Airbnb ya no intenta realzar el romanticismo de compartir el hogar. Sobre un total de 6343 cuentas de anfitriones distintas, la gran mayoría publica un sólo alojamiento, y lo ofrece de forma completa: no se trata de compartir el hogar, son departamentos ofrecidos en alquiler temporario, buscando una renta más alta que la que permite el inquilino local. Y aún los alojamientos compartidos -los que aparecen como “habitación privada”, o “habitación compartida”- pueden representar una propiedad en la que el dueño aloja multiples clientes, repartiéndolos en las habitaciones disponibles. Para más detalles:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;airba_df %&amp;gt;% 
  count(room_type) %&amp;gt;% 
  ungroup() %&amp;gt;% 
  mutate(pct = n / sum(n)) %&amp;gt;% 
  ggplot(aes(factor(room_type), pct)) + 
  geom_col(fill = &amp;quot;salmon&amp;quot;) + 
  scale_y_percent() +
  theme_ipsum(grid = &amp;quot;Y&amp;quot;) +
  labs(title = &amp;quot;Modalidad de los alojamientos ofrecidos&amp;quot;,
       subtitle= paste(&amp;quot;Total de alojamientos:&amp;quot;, nrow(airba_df)),
       y = &amp;quot;porcentaje&amp;quot;,
       x = &amp;quot;tipo&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-09-analizando-data-de-airbnb-en-buenos-aires_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;De los 9923 alojamientos ofrecidos, 7709 (un 77%) son propiedades enteras.&lt;/p&gt;
&lt;p&gt;Otro punto interesante es la categoría “Más de 10 alojamientos publicados”. Hay algunos pocos usuarios que administran más de 10 publicaciones. Pero hasta cuántas llegan? Veamos cuantos alojamientos mantienen los 5 usuarios que más ofertan:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;airba_df %&amp;gt;% 
  group_by(host_id) %&amp;gt;% 
  summarise(&amp;quot;Alojamientos ofrecidos&amp;quot; = n()) %&amp;gt;% 
  pull(&amp;quot;Alojamientos ofrecidos&amp;quot;) %&amp;gt;% 
  sort(decreasing = T) %&amp;gt;% 
  head(n=5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 87 77 73 62 44&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Existen cuentas que administran 73, 77… ¡87! alojamientos distintos, ofrecidos a la vez. No es una operación menor la de mantener semejante número de propiedades en rotación, por lo cual podemos asumir que se trata de empresas (formalizadas como tales, o no) dedicadas a alojar turistas via Airbnb. Lo cual nos lleva a…&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;distribucion-de-ingresos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3. Distribución de ingresos&lt;/h2&gt;
&lt;p&gt;Aquí hay que aclarar una vez más que nos basamos en estimados. De todas formas, aún si no sabemos en qué grado nuestra suposición se aproxima a los números reales, aplicar la misma medición a todos los usuarios nos permite comparar que tan bien les está yendo con el negocio. Allá vamos:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;usuarios %&amp;gt;% 
  ggplot(aes(ingresos_estimados)) +
  geom_histogram(fill=&amp;quot;salmon&amp;quot;, bins = 400) + 
  theme_ipsum(grid = &amp;quot;Y&amp;quot;) +
  scale_x_comma() +
  labs(title = &amp;quot;Distribución de ingresos&amp;quot;,
       subtitle = &amp;quot;valores estimados&amp;quot;,
       y = &amp;quot;n&amp;quot;,
       x = &amp;quot;ingresos (ARS)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-09-analizando-data-de-airbnb-en-buenos-aires_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;OK. Lo que ocurre aquí es que hay un puñado de usuarios que han recaudado de forma cuantiosa de acuerdo a nuestros supuestos, estirando la escala al punto que no podemos diferenciar al pelotón de los no tan afortunados. En otras palabras, una &lt;a href=&#34;https://es.wikipedia.org/wiki/Distribuci%C3%B3n_de_Pareto&#34;&gt;distribución de pareto&lt;/a&gt; peliaguda. Acudimos al viejo aliado de la visualización de ingresos, la escala logarítmica.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;usuarios %&amp;gt;% 
  ggplot(aes(ingresos_estimados)) +
  geom_histogram(fill=&amp;quot;salmon&amp;quot;, bins = 100) + 
  theme_ipsum(grid = &amp;quot;XY&amp;quot;) +
  scale_x_log10(breaks = c(1000, 10000, 100000, 1000000, 10000000)) +
  labs(title = &amp;quot;Distribución de ingresos&amp;quot;,
       subtitle = &amp;quot;valores estimados&amp;quot;,
       y = &amp;quot;cantidad de usuarios&amp;quot;,
       x = &amp;quot;ingresos alcanzados (ARS)&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-09-analizando-data-de-airbnb-en-buenos-aires_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(usuarios$ingresos_estimados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
##        0        0    16669   232754   103160 31654204&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahí queda más claro el panorama. Unas tres cuartas partes ha recaudado menos de 100.000 pesos en el tiempo (días, meses, años) que lleva publicando sus propiedades en la plataforma. Pero los del cuartil superior absorben una cantidad desproporcionada de los ingresos totales generados, con un tope de ingresos (otra vez, estimado) de más de 30 millones de pesos.&lt;/p&gt;
&lt;p&gt;¿Qué tan desigual es esta distribución? Hagamos un favorito de la casa, el &lt;a href=&#34;https://eagereyes.org/blog/2008/engaging-readers-with-square-pie-waffle-charts&#34;&gt;gráfico waffle&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(waffle)

reparto &amp;lt;- usuarios %&amp;gt;% 
  group_by(categoria_ingresos) %&amp;gt;% 
  summarise(ingresos_totales = sum(ingresos_estimados)) 

reparto &amp;lt;- structure(reparto[[2]] / 10000000, names = reparto[[1]])
reparto &amp;lt;- round(reparto[c(2,3,1)])

waffle(reparto,
       rows = 10,
       colors=c(&amp;quot;salmon&amp;quot;, &amp;quot;lightsalmon&amp;quot;, &amp;quot;bisque1&amp;quot;),
       legend_pos = &amp;quot;bottom&amp;quot;,
       xlab = &amp;quot;1 cuadro == 10 millones de pesos&amp;quot;,
       title = &amp;quot;Reparto de ingresos&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-09-analizando-data-de-airbnb-en-buenos-aires_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# En porcentajes:
round(reparto / sum(reparto), 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      top 1 % top 2% a 10%        resto 
##         0.35         0.45         0.20&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El top 1% de los anfitriones con mayores ingresos se lleva más de un tercio de la torta (quiero decir, del waffle). El 10% con mayores ingresos factura un 80% del total. &lt;strong&gt;Es un mercado muy, muy concentrado.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;distribucion-geografica&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;4. Distribución geográfica&lt;/h2&gt;
&lt;p&gt;¿Dónde se conentran los alojamientos ofrecidos? Y en particular, ¿dónde están los alojamientos que más recaudan?&lt;/p&gt;
&lt;p&gt;A mapear!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggmap)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;map.ba &amp;lt;- qmap(&amp;quot;Caballito, Buenos Aires&amp;quot;, zoom = 12, source=&amp;quot;stamen&amp;quot;, 
                maptype=&amp;quot;toner-hybrid&amp;quot;)     

map.ba +
  coord_equal() +
  stat_bin_hex(data = airba_df, aes(x=longitude, y=latitude), alpha = .7) +
  #stat_density2d(data=airba_df, aes(x=longitude, y=latitude, color=..density..,
  #                                  size=ifelse(..density..&amp;lt;=1,0,..density..), 
  #                                  alpha=..density..), geom=&amp;quot;tile&amp;quot;,contour=F) +
  scale_fill_gradientn(colours=c(&amp;quot;lightblue&amp;quot;,&amp;quot;red&amp;quot;), na.value=NA) +
  geom_point(data = usuarios %&amp;gt;% 
               left_join(airba_df) %&amp;gt;% 
               filter(categoria_ingresos == &amp;quot;top 1 %&amp;quot;), 
             aes(x=longitude, y=latitude), alpha = .3, shape = 3) +
  theme_ipsum(grid = FALSE) +
  labs(y = &amp;quot;&amp;quot;, x = &amp;quot;&amp;quot;,
       title=&amp;quot;Concentración geográfica&amp;quot;,
       subtitle = &amp;quot;Las cruces representan alojamientos publicados por usuarios en el top 1% de ingresos&amp;quot;,
       fill = &amp;quot;Densidad de\nalojamientos&amp;quot;) +
  # Eliminamos las etiquetas de latitud y longitud de los ejes 
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-09-analizando-data-de-airbnb-en-buenos-aires_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Lo que hemos graficado es el corredor turístico La Boca - San Telmo - Barrio Norte - Palermo. Ahí es donde se concentran las propiedades ofrecidas, y dónde basan su oferta los usuarios que más ingresos perciben. La distribución de la oferta replica la desigualdad territorial de la ciudad, recordando con bastante fidelidad a la distrución del precio del suelo:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/img/reporte_inmobiliario.png&#34; alt=&#34;vía http://www.reporteinmobiliario.com&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;vía &lt;a href=&#34;http://www.reporteinmobiliario.com&#34; class=&#34;uri&#34;&gt;http://www.reporteinmobiliario.com&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Y también explica el sesgo de &lt;a href=&#34;https://www.airbnb.com/things-to-do/buenos-aires&#34;&gt;“La guía definitiva de los mejores lugares” en Buenos Aires&lt;/a&gt; que publica Airbnb.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/img/thingsinba.jpg&#34; alt=&#34;no puedo evitar irritarme vacada vez que veo esta imagen&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;no puedo evitar irritarme vacada vez que veo esta imagen&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;De acuerdo a la plataforma, todos los mejores lugares se encuentran en el &lt;em&gt;downtown&lt;/em&gt; o en los barrios más caros de la ciudad. Ni siquiera La Boca, con su hiperturístico Caminito, logró colar un lugar recomendable en la lista de Airbnb. Puede argumentarse que la seleccion responde a la lógica de recomendar lugares en zonas donde abunda la oferta de alojamientos provistos por Airbnb, para que los visitantes tentados encuentren un lugar que alquilar. Pero en todo caso, no ayuda a disipar los fantasmas de &lt;em&gt;gentrificación&lt;/em&gt; que revolotean en torno al accionar de la empresa. En Berlín, las autoridades decidieron &lt;a href=&#34;https://www.theguardian.com/technology/2016/may/01/berlin-authorities-taking-stand-against-airbnb-rental-boom&#34;&gt;prohibir el alquiler de propiedades enteras a turistas&lt;/a&gt; mediante plataformas como Airbnb. La empresa &lt;a href=&#34;https://www.airbnb.com/berlin-economic-impact&#34;&gt;responde&lt;/a&gt; que los visitantes que atrae “apoyan la economía local por toda la ciudad” y que al “alojarse junto a un local” los turistas toman una perspectiva “desde adentro” de la ciudad. Verificar estos postulados para Berlin queda pendiente, pero en lo que respecta a Buenos Aires mi conclusión es que la plataforma, lejos de contribuir a un desarrollo económico parejo de la ciudad, parece más apta para recrudecer su desigualdad preexistente.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Predicción de demanda de servicios urbanos con open data &#43; Facebook Prophet</title>
      <link>/post/prediccion-de-demanda-de-servicios-urbanos-con-prophet/</link>
      <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
      <author>avazquez@gmail.com (H. Antonio Vazquez Brust)</author>
      <guid>/post/prediccion-de-demanda-de-servicios-urbanos-con-prophet/</guid>
      <description>&lt;p&gt;De todos los datasets que publica el portal de Open Data de Buenos Aires, mi favorito es sin dudas el que contiene los reclamos registrados por el Sistema Único de Atención Ciudadana (SUACI). El SUACI, también llamado &lt;a href=&#34;https://gestioncolaborativa.buenosaires.gob.ar/prestaciones&#34;&gt;BA 147&lt;/a&gt;, equivale a lo que en otras latitudes se conoce como &lt;a href=&#34;https://en.wikipedia.org/wiki/3-1-1&#34;&gt;servicio 311&lt;/a&gt;. El 311 es el número telefónico, complementado por un servicio web y en general una app también, al que los ciudadanos recurren para realizar reclamos al gobierno de la ciudad. En contraste con el servicio 911, el 311 (o 147 en Buenos Aires) se utiliza para reportar problemas que no involucran urgencias de salud o seguridad. Por ejemplo, si la cuadra de uno aparece llena de basura después de un evento multitudinario en las cercanías, se llama al 147 o se usa la app para que la ciudad envíe una cuadrilla de limpieza. En cambio, si una persona sufre un infarto en la vía pública, se llama al 911.&lt;/p&gt;
&lt;p&gt;Si esto les resulta un poco confuso, no se preocupen, nos es culpa nuestra; hay un ligero exceso de nombres distintos para cosas similares. Los nombres SUACI y BA 147 coexisten porque -creo- SUACI registra las solicitudes al 147 pero también reclamos enviados a la ciudad por otros medios. En cuanto a 311 vs. 147, la popularidad de 311 como número para reclamos aún muy lejos del archifamoso 911. Por eso muchas ciudades en el mundo, BA incluida, coinciden en usar el 911 para emergencias pero varían en el número reservado para reclamos cotidianos.&lt;/p&gt;
&lt;p&gt;Lo interesante de los servicios tipo 311 es que, cuando sus registros se comparten con el público, permiten hacer estudios sobre muchas facetas de la ciudad. Por ejemplo, &lt;a href=&#34;http://blog.datalook.io/using-data-analytics-to-make-bad-buildings-better-in-new-york-city/&#34;&gt;identificar edificios peligrosos por su deterioro&lt;/a&gt;, o probar que las “fronteras” entre comunidades distintas dentro de la ciudad &lt;a href=&#34;https://nextcity.org/daily/entry/311-calls-neighborhood-study&#34;&gt;generan más reclamos que áreas homogéneas&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Un área que creo de particular interés es la de predecir demanda a futuro de servicios urbanos, para ayudar a planificar la asignación de los siempre limitados recursos públicos. Analizando la cantidad de reclamos que la población realiza a lo largo del tiempo, podemos detectar tendencias y pronosticar demanda futura, así como predecir los momentos y lugares de “tranquilidad” (que requieren menos recursos) así como aquellos que generan picos (donde se van a necesitar refuerzos).&lt;/p&gt;
&lt;p&gt;A todo ésto, el área de I+D de Facebook liberó recientemente sus algoritmos de modelado y predicción para datos seriados en el tiempo, bajo el nombre de &lt;a href=&#34;https://facebookincubator.github.io/prophet/&#34;&gt;Prophet&lt;/a&gt;. La razón por la cual Prophet me resultó llamativo de inmediato es que hace muy fácil incorporar el efecto de días atípicos en un modelo predictivo para procesos que se desarrollan a lo largo del tiempo. En palabras de urbanista: podemos pronosticar la demanda de servicios urbanos usando registros históricos, generando un modelo que toma en cuenta el efecto de los diversos días feriados.&lt;/p&gt;
&lt;p&gt;Allá vamos!&lt;/p&gt;
&lt;div id=&#34;obteniendo-los-datos-de-la-ciudad&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Obteniendo los datos de la ciudad&lt;/h2&gt;
&lt;p&gt;El primer paso es descargar los datos que necesitamos. Visitamos &lt;a href=&#34;https://data.buenosaires.gob.ar/&#34;&gt;Buenos Aires Data&lt;/a&gt;, buscamos “Sistema Único de Atención Ciudadana”, y llegamos a la página de descarga que nos interesa - &lt;a href=&#34;https://data.buenosaires.gob.ar/dataset/sistema-unico-de-atencion-ciudadana&#34;&gt;aquí&lt;/a&gt;. Tenemos disponible un link para descargar un archivo comprimido que contiene los datos que buscamos. Podemos dejar que R se encargue de acceder al sitio, descargar y descomprimir por nosotros:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Donde vive nuestra data?
url &amp;lt;- &amp;quot;https://data.buenosaires.gob.ar/api/datasets/rJg_9jlR5/download&amp;quot;

# Donde queremos guardarla
destino &amp;lt;- &amp;#39;/home/havb/data/gcba/suaci&amp;#39;

# Creamos un archivo temporal para dscargar el zip con todos los datasets
temp &amp;lt;- tempfile()

# Descargamos -puede tomar unos cuantos minutos
download.file(url, temp)

# Des-zipeamos
unzip(temp, exdir = destino, junkpaths = TRUE)

# Eliminamos el archivo temporal
unlink(temp)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Terminado el trámite, revisamos nuestro botín:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list.files(destino)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;sistema-unico-de-atencion-ciudadana-2011.csv&amp;quot;
## [2] &amp;quot;sistema-unico-de-atencion-ciudadana-2012.csv&amp;quot;
## [3] &amp;quot;sistema-unico-de-atencion-ciudadana-2013.csv&amp;quot;
## [4] &amp;quot;sistema-unico-de-atencion-ciudadana-2014.csv&amp;quot;
## [5] &amp;quot;sistema-unico-de-atencion-ciudadana-2015.csv&amp;quot;
## [6] &amp;quot;sistema-unico-de-atencion-ciudadana-2016.csv&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;He aquí el primer problema. En lugar de darnos un dataset con todo el historial de registros, nos dan una pila archivos que contienen la data separada por año. Cuando uno analiza datos a lo largo del tiempo, lo natural es tenerlos todos juntos, y luego segmentarlos -por año, por mes, o por otro período arbitrario- cuando es necesario. Y desde ya que cuando uno analiza tendencias para predecir, como estamos haciendo ahora, necesita todos los datos juntos. En fin, no es tan grave… solo es cuestión de pegar los datasets uno después del otro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(lubridate)

# Obtener la lista de archivos .csv que descargamos 

archivos &amp;lt;- list.files(path = destino, pattern = &amp;quot;\\.csv&amp;quot;, full.names = TRUE)

# A procesar!

suaci &amp;lt;-  archivos %&amp;gt;% 
  # leer cada archivo, guardar el resultado en un sólo dataframe
  map_df(read_csv2) %&amp;gt;% 
  # determinar la fecha a partir unieendo los campos FECHA_INGRESO, HORA_INGRESO, 
  # interpretando el resultado en formato &amp;quot;día/mes/año hora:min:sec [AM|PM]&amp;quot; 
  mutate(fecha = parse_date_time(paste(FECHA_INGRESO, HORA_INGRESO), &amp;quot;d/m/Y IMS p&amp;quot;, tz = &amp;quot;America/Argentina/Buenos_Aires&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora, exploremos los datos unificados. Rapidito, un top ten de los reclamos más frecuentes:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;suaci %&amp;gt;% 
  group_by(CONCEPTO, RUBRO) %&amp;gt;% 
  summarise(total = n()) %&amp;gt;% 
  arrange(desc(total)) %&amp;gt;%
  head(10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 x 3
## # Groups:   CONCEPTO [10]
##    CONCEPTO                                           RUBRO          total
##    &amp;lt;chr&amp;gt;                                              &amp;lt;chr&amp;gt;          &amp;lt;int&amp;gt;
##  1 SOLICITUD DE PARTIDAS                              REGISTRO CIV… 818151
##  2 SOLICITUD DE PAGO VOLUNTARIO DE INFRACCIONES       TRANSPORTE Y… 358298
##  3 PERSONAS SIN TECHO EVALUACION                      ATENCION SOC… 138741
##  4 LUMINARIAS APAGADAS                                ALUMBRADO     115234
##  5 SOLICITUD DE RETIRO DE RESIDUOS VOLUMINOSOS        SANEAMIENTO …  86978
##  6 SOLICITUD DE RETIRO DE RESTOS DE OBRAS O DEMOLICI… SANEAMIENTO …  81570
##  7 RETIRO DE ESCOMBROS (RESIDUOS ARIDOS)              SANEAMIENTO …  75983
##  8 LUMINARIA: APAGADA                                 ALUMBRADO      63788
##  9 VEHICULOS ABANDONADOS EN VIA PUBLICA LEY 342       TRANSPORTE Y…  47773
## 10 SOLICITUD DE REPOSICION O CAMBIO DE UBICACION DE … SANEAMIENTO …  47709&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hay algunos problemas. Categorías como “LUMINARIAS APAGADAS” y “LUMINARIA: APAGADA” son obvias referencias al mismo reclamo, registradas bajo categorías distintas. Podemos dejarlo pasar, porque no afecta a nuestros fines.&lt;/p&gt;
&lt;p&gt;Lo que vamos a modelar son las solicitudes al departamento de saneamiento urbano: reclamos de la ciudadanía para que la ciudad retire residuos voluminosos, escombros de obra, ramas podadas, etc. Aquí vale la pena insistir en la riqueza del dataset. Entre las categorías que aparecen con solo mirar las principales, aparecen la atención a personas sin techo, y los problemas de iluminación pública. Hay, tantas, tantas cosas que se pueden hacer mediante el análisis espacial y temporal de la data!&lt;/p&gt;
&lt;p&gt;Aislamos los reclamos que nos interesan en este momento:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;solicitudes_saneamiento &amp;lt;- suaci %&amp;gt;%
  filter(grepl(&amp;quot;RESIDUOS|RESTOS|ESCOMBROS &amp;quot;, CONCEPTO) == TRUE &amp;amp; 
           RUBRO == &amp;quot;SANEAMIENTO URBANO&amp;quot;) %&amp;gt;% 
  group_by(dia = format(fecha, &amp;quot;%Y-%m-%d&amp;quot;)) %&amp;gt;% 
  summarise(total = n())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y ahora los graficamos para ver que pinta tienen:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(hrbrthemes)

ggplot(solicitudes_saneamiento, aes(as.Date(dia), total)) + 
  geom_line(color = &amp;quot;orange&amp;quot;) +
  scale_x_date(date_labels = &amp;quot;%Y-%m&amp;quot;) +
  theme_ipsum() +
  labs(y = &amp;quot;solicitudes&amp;quot;, x = &amp;quot;fecha&amp;quot;,
       title=&amp;quot;Demanda diaria de servicios de saneamiento urbano&amp;quot;,
       subtitle = &amp;quot;Ciudad de Buenos Aires: 2011 - 2016&amp;quot;,
       caption = &amp;quot;Fuente: https://data.buenosaires.gob.ar/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-27-prediccion-de-demanda-de-servicios-urbanos-con-prophet_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;A primera vista, es obvio que los datos están sesgados, ya que la explosión en el número de solicitudes a partir de mediados del 2012 es atribuible a la forma en que la ciudad empezó a tomar nota de los reclamos, más que a un furor ciudadano por solicitar limpieza. Cuando hagamos nuestro modelo, vamos a descartar los registros de 2011 y 2012 porque tenemos claro que no son representativos.&lt;/p&gt;
&lt;p&gt;El siguiente ingrediente que necesitamos es una lista de los feriados públicos en la Argentina durante el período analizado.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;cuando-los-datos-estan-dispersos-la-hora-del-scraping&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Cuando los datos están dispersos: la hora del scraping&lt;/h2&gt;
&lt;p&gt;Buscar una lista oficial de feriados resultó en frustración. Si bien el gobierno nacional publica una lista de los &lt;a href=&#34;https://www.argentina.gob.ar/feriados&#34;&gt;feriados vigentes para el año en curso&lt;/a&gt;, no existe un archivo para descargar con las fechas exactas de los feriados en años anteriores.&lt;/p&gt;
&lt;p&gt;En los sitios web de varios diarios locales encontramos un historial de feriados, pero dispersos en distintas páginas web, y sin opción para descargarlos en un archivo de texto. Vamos a tener que “scrapear” la data. Cómo nos hacen laburar, che. Si tan solo alguien nos diera una API para toda información de consulta permanente, no tendríamos que hacer estas cosas!&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/img/API.png&#34; alt=&#34;ira&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;ira&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Nuestro proveedor de fechas de feriados será La Nación, que publica un bonito &lt;a href=&#34;http://servicios.lanacion.com.ar/feriados/&#34;&gt;calendario de feriados oficiales&lt;/a&gt;, con la posibilidad de consultar los de años anteriores.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rvest)

# Una función que hace scraping de todos los feriados publicados en lanacion.com.ar para un año dado

scrape_feriados_del_anio &amp;lt;- function(year) {
  
  # Donde está la data de los feriados
  baseurl &amp;lt;- &amp;quot;http://servicios.lanacion.com.ar/feriados/&amp;quot;
  
  get_feriados_mes &amp;lt;- function(month, feriados_page) {
    
    # Los feriados aparecen en dos categorías: &amp;quot;inamovible&amp;quot; y &amp;quot;trasladable&amp;quot;
    
    inamovibles &amp;lt;- feriados_page %&amp;gt;%
      map(html_nodes, &amp;quot;li.inamovible&amp;quot;) %&amp;gt;%
      map(html_text) %&amp;gt;%
      .[[month]] %&amp;gt;%
      {if (!is_empty(.)) paste(year, month, ., sep = &amp;quot;/&amp;quot;)}
  
    trasladables  &amp;lt;- feriados_page %&amp;gt;%
      map(html_nodes, &amp;quot;li.trasladable&amp;quot;) %&amp;gt;%
      map(html_text) %&amp;gt;% 
      .[[month]] %&amp;gt;%
      {if (!is_empty(.)) paste(year, month, ., sep = &amp;quot;/&amp;quot;)}
    
    todos &amp;lt;- c(inamovibles, trasladables) 
    
    if (!is.null(todos)) return(todos)
    
    }
  
  feriados_page &amp;lt;- read_html(paste0(baseurl, year)) %&amp;gt;% 
    html_nodes(&amp;quot;.bloque&amp;quot;)
  
  feriados_del_anio &amp;lt;- map(1:12, get_feriados_mes, feriados_page) %&amp;gt;% 
    unlist()
  
  return(feriados_del_anio)
}
  

# Descargamos los feriados de 2011 a 2016,  
feriados_2013_2016 &amp;lt;- map(2013:2016, scrape_feriados_del_anio) %&amp;gt;% 
  #los unimos en un unico vector
  unlist %&amp;gt;% 
  # los definimos como fecha
  ymd %&amp;gt;% 
  # Los ordenamos cronológicamente (necesario porque el scraper los trae como texto 
  # en orden alfabetico)
  sort&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tenemos nuestra lista de feriados?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;feriados_2013_2016&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;2013-01-01&amp;quot; &amp;quot;2013-01-31&amp;quot; &amp;quot;2013-02-11&amp;quot; &amp;quot;2013-02-12&amp;quot; &amp;quot;2013-02-20&amp;quot;
##  [6] &amp;quot;2013-03-24&amp;quot; &amp;quot;2013-03-29&amp;quot; &amp;quot;2013-04-01&amp;quot; &amp;quot;2013-04-02&amp;quot; &amp;quot;2013-05-01&amp;quot;
## [11] &amp;quot;2013-05-25&amp;quot; &amp;quot;2013-06-20&amp;quot; &amp;quot;2013-06-21&amp;quot; &amp;quot;2013-07-09&amp;quot; &amp;quot;2013-08-19&amp;quot;
## [16] &amp;quot;2013-10-14&amp;quot; &amp;quot;2013-11-25&amp;quot; &amp;quot;2013-12-08&amp;quot; &amp;quot;2013-12-25&amp;quot; &amp;quot;2014-01-01&amp;quot;
## [21] &amp;quot;2014-03-03&amp;quot; &amp;quot;2014-03-04&amp;quot; &amp;quot;2014-03-24&amp;quot; &amp;quot;2014-04-02&amp;quot; &amp;quot;2014-04-18&amp;quot;
## [26] &amp;quot;2014-05-01&amp;quot; &amp;quot;2014-05-02&amp;quot; &amp;quot;2014-05-25&amp;quot; &amp;quot;2014-06-20&amp;quot; &amp;quot;2014-07-09&amp;quot;
## [31] &amp;quot;2014-08-18&amp;quot; &amp;quot;2014-10-13&amp;quot; &amp;quot;2014-11-24&amp;quot; &amp;quot;2014-12-08&amp;quot; &amp;quot;2014-12-25&amp;quot;
## [36] &amp;quot;2014-12-26&amp;quot; &amp;quot;2015-01-01&amp;quot; &amp;quot;2015-02-16&amp;quot; &amp;quot;2015-02-17&amp;quot; &amp;quot;2015-03-23&amp;quot;
## [41] &amp;quot;2015-03-24&amp;quot; &amp;quot;2015-04-02&amp;quot; &amp;quot;2015-04-03&amp;quot; &amp;quot;2015-05-01&amp;quot; &amp;quot;2015-05-25&amp;quot;
## [46] &amp;quot;2015-06-20&amp;quot; &amp;quot;2015-07-09&amp;quot; &amp;quot;2015-08-17&amp;quot; &amp;quot;2015-10-12&amp;quot; &amp;quot;2015-11-27&amp;quot;
## [51] &amp;quot;2015-12-07&amp;quot; &amp;quot;2015-12-08&amp;quot; &amp;quot;2015-12-25&amp;quot; &amp;quot;2016-01-01&amp;quot; &amp;quot;2016-02-08&amp;quot;
## [56] &amp;quot;2016-02-09&amp;quot; &amp;quot;2016-03-24&amp;quot; &amp;quot;2016-03-25&amp;quot; &amp;quot;2016-04-02&amp;quot; &amp;quot;2016-05-01&amp;quot;
## [61] &amp;quot;2016-05-25&amp;quot; &amp;quot;2016-06-17&amp;quot; &amp;quot;2016-06-20&amp;quot; &amp;quot;2016-07-08&amp;quot; &amp;quot;2016-07-09&amp;quot;
## [66] &amp;quot;2016-08-15&amp;quot; &amp;quot;2016-10-10&amp;quot; &amp;quot;2016-11-28&amp;quot; &amp;quot;2016-12-08&amp;quot; &amp;quot;2016-12-09&amp;quot;
## [71] &amp;quot;2016-12-25&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Oh si.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;modelando-y-prediciendo&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Modelando y prediciendo&lt;/h2&gt;
&lt;p&gt;Con todos los ingredientes a mano, es hora de hacer vaticinios. Como suele pasar cuando uno trabaja con datos, hacer el modelo es la parte más sencilla… la mayor parte del tiempo la empleamos en reunir y limpiar los datos!&lt;/p&gt;
&lt;p&gt;Creamos un modelo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(prophet)

modelo &amp;lt;- solicitudes_saneamiento %&amp;gt;% 
  filter(year(as.Date(dia)) &amp;gt; 2012) %&amp;gt;% 
  transmute(ds = as.Date(dia), y = total) %&amp;gt;%  
  prophet(holidays = data.frame(holiday = &amp;quot;feriado&amp;quot;, ds = feriados_2013_2016))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Initial log joint probability = -116.558
## Optimization terminated normally: 
##   Convergence detected: relative gradient magnitude is below tolerance&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y predecimos la demanda para el año siguiente (todo el 2017):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;forecast &amp;lt;- predict(modelo, make_future_dataframe(modelo, periods = 365))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;De paso, hacemos dos preguntas rápidas. Cuantas solicitudes diarias recibe la ciudad, y que efecto tiene un día feriado en el nivel de demanda?&lt;/p&gt;
&lt;p&gt;Durante el período 2013-2016, el área de saneamiento urbano de la ciudad recibió un promedio de 394 reclamos diarios, con un máximo 1075. El día en el que menos reclamos se registraron sólo hubo 3.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;modelo$history$y %&amp;gt;% summary&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##     3.0   121.0   392.0   394.1   603.5  1075.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Según nuestro modelo, el efecto de que un feriado caiga en un día particular del mes es una reducción de 401 reclamos. En un día típico, esto haría que prácticamente no haya reclamos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;forecast %&amp;gt;% 
  select(ds, feriado) %&amp;gt;% 
  filter(abs(feriado) &amp;gt; 0) %&amp;gt;% 
  head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           ds   feriado
## 1 2013-01-01 -401.1635
## 2 2013-01-31 -401.1635
## 3 2013-02-11 -401.1635
## 4 2013-02-12 -401.1635
## 5 2013-02-20 -401.1635
## 6 2013-03-24 -401.1635&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Visualizando por separado la tendencias general y las periódicas (por día de la semana y día del mes) notamos varios efectos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;La tendencia general fue una baja del nivel de demanda desde el 2014 hasta el 2016, revertida luego. Se evidencia una fuerte suba de allí en más. Valdría la pena discernir si esto se debe a que la data sub-representa los reclamos del 2014-2016, o si efectivamente ocurrió una baja de demanda en esos años. Si ésto último fuera el caso, a que podría deberse?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;El día de mayor actividad es el Lunes, a continuación de los días más tranquilo, los del fin de semana. Está claro que en Domingo la gente no reclama mucho, pero al día siguiente si. En el resto de los días la demanda es pareja&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tal como habíamos comprobado revisando los números, los días feriados generan una caída de unos 400 reclamos&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Los meses de mayor actividad son los de la segunda mitad del año. Durante las vacaciones de invierno se observa una baja de la demanda, leve en comparación a la de fin de año…. a partir de mediados de Diciembre, la demanda cae en picada, y se mantiene mínima en Enero.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;prophet_plot_components(modelo, forecast) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-27-prediccion-de-demanda-de-servicios-urbanos-con-prophet_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Y por último, trazamos la predicción de nivel de demanda para lo que queda del año:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(modelo, forecast) + theme_ipsum() +
  labs(y = &amp;quot;solicitudes&amp;quot;, x = &amp;quot;fecha&amp;quot;,
       title=&amp;quot;Pronóstico: demanda diaria de servicios de saneamiento urbano&amp;quot;,
       subtitle = &amp;quot;Ciudad de Buenos Aires: 2013 - 2016, extendido a final del 2017&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-27-prediccion-de-demanda-de-servicios-urbanos-con-prophet_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Yo diría que, a no ser que esté operando con capacidad de sobra, Saneamiento Urbano va a necesitar más recursos!&lt;/p&gt;
&lt;p&gt;Para la próxima: hacer análisis espacial además del temporal.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Visualizando con R el historial de ubicaciones de Google (parte III)</title>
      <link>/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-iii/</link>
      <pubDate>Sat, 10 Jun 2017 00:00:00 +0000</pubDate>
      <author>avazquez@gmail.com (H. Antonio Vazquez Brust)</author>
      <guid>/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-iii/</guid>
      <description>&lt;p&gt;En la &lt;a href=&#34;https://bitsandbricks.github.io/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-iI/&#34;&gt;entrega anterior&lt;/a&gt;, seguimos el rastro del usuario a través de las calles, y descubrimos donde vive.&lt;/p&gt;
&lt;p&gt;Como cierre, vamos a visualizar los vuelos con los que el usuario conectó las ciudades por donde estuvo.&lt;/p&gt;
&lt;p&gt;Para reproducir los resultados, recomiendo correr antes el código de la &lt;a href=&#34;https://bitsandbricks.github.io/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i/&#34;&gt;parte I&lt;/a&gt;, que deja preparados los sets de datos que vamos a utilizar aquí.&lt;/p&gt;
&lt;div id=&#34;identificando-vuelos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Identificando vuelos&lt;/h2&gt;
&lt;p&gt;Durante los ejercicios anteriores, notamos que los datos contienen ubicaciones registradas a ambos lados del Atlántico. A no ser que nuestro viajero haya optado por largos viajes en barco, podemos estar seguros de que ha tomado varios aviones. ¿Cómo podemos detectar los destinos unidos mediante vuelos?&lt;/p&gt;
&lt;p&gt;Tras experimentar con varios métodos, me encontré con que la forma más simple es buscar registros de ubicación consecutivos separados por más de 250 Km. Tomando ventaja de la prohibición de usar las antenas del celular durante el vuelo, asumimos que si alguien recorrió un largo trecho desde su última conexión a GPS ha estado a bordo de una aeronave. Hay que aclarar que este criterio podría producir falsos positivos en caso de que el usuario haya viajado en auto por larguísimos trechos con su celular apagado (y falsos negativos en el caso de tramos en avión muy breves).&lt;/p&gt;
&lt;p&gt;A continuación necesitamos traducir a metros la distancias entre geo-coordenadas. Podríamos escribir una función que aplique la &lt;a href=&#34;https://es.wikipedia.org/wiki/F%C3%B3rmula_del_haversine&#34;&gt;fórmula del haversine&lt;/a&gt;, o haciendo gala de una saludable pereza, usar la que viene incluida en el paquete &lt;code&gt;geosphere&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(geosphere)

# Cargamos el dataset con el historial de ubicaciones, obtenido en  # https://bitsandbricks.github.io/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i/

locationdf &amp;lt;- read.csv(&amp;#39;/home/havb/data/Google/Location History/locationdf.csv&amp;#39;, 
                       stringsAsFactors = F)
class(locationdf$date) &amp;lt;- &amp;#39;POSIXct&amp;#39;

# La funcion distGeo toma dos listas con sets de coordenadas, 
# y devuelve la distancia en m
distance &amp;lt;- distGeo(locationdf[-nrow(locationdf), c(&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;)], 
                      locationdf[-1, c(&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;)])

# Unimos los datos de distancia con el dataset de ubicaciones
# Descartamos la primera fila del dataset de ubicaciones, ya que al no registrarse 
# una posición previa, no permite calcular distancia recorrida

locationdf &amp;lt;- cbind(locationdf[-1,], distance)

# Agregamos un indice al dataframe, que nos va a servir luego 
# para encontrar el origen de los viajes

locationdf &amp;lt;- cbind(index = 1:nrow(locationdf), locationdf)

# Extraemos los destinos de los vuelos (arrivos a más de 250 KM del último registro)
flights &amp;lt;- locationdf %&amp;gt;% 
  select(index, lat, lon, date, year, CITY_NAME, CNTRY_NAME, distance) %&amp;gt;% 
  filter(distance &amp;gt; 250000) 

# Agregamos el lugar de salida de los vuelos

findOrigin &amp;lt;- function(index) {
  return(data.frame(prev_lat = locationdf[locationdf$index == index-1, &amp;quot;lat&amp;quot;],
                    prev_lon = locationdf[locationdf$index == index-1, &amp;quot;lon&amp;quot;],
                    prev_city = locationdf[locationdf$index == index-1, &amp;quot;CITY_NAME&amp;quot;])
         )
}

# Finalmente, nuestra lista de vuelos
flights &amp;lt;- cbind(flights, map_df(flights$index, findOrigin))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La lista de vuelos encontrados luce así (versión abreviada):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(flights[c(&amp;quot;CITY_NAME&amp;quot;, &amp;quot;prev_city&amp;quot;, &amp;quot;distance&amp;quot;, &amp;quot;year&amp;quot;)])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      CITY_NAME             prev_city  distance year
## 1        Salta          Buenos Aires  934818.1 2011
## 2 Buenos Aires San Miguel De Tucuman  850142.9 2011
## 3  Resistencia          Buenos Aires  416533.2 2011
## 4 Buenos Aires           Resistencia  416909.9 2011
## 5       Madrid          Buenos Aires 8786212.0 2011
## 6    Amsterdam                Madrid 1632970.9 2012&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Transformar la lista en una visualización es simple; sólo trazamos sobre un mapamundi las lineas que conectan orígenes y destinos:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(mapdata)

maps::map(&amp;quot;world&amp;quot;, col=&amp;quot;#f2f2f2&amp;quot;, fill=TRUE, bg=&amp;quot;white&amp;quot;, lwd=0.15)#, xlim=xlim, ylim=ylim)

points(bind_rows(flights[, c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;)], 
             flights[, c(&amp;quot;prev_lon&amp;quot;, &amp;quot;lat&amp;quot;)]), 
       col = &amp;quot;red&amp;quot;)

lines(bind_rows(flights[, c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;)], 
             flights[, c(&amp;quot;prev_lon&amp;quot;, &amp;quot;lat&amp;quot;)]), 
      col = &amp;quot;orange&amp;quot;, lwd=2)
title( main = &amp;quot;:/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-10-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-iii_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Simple si, pero esas líneas rectas quedan bastante raras. Dado que nuestro planeta es un esferoide, si proyectamos sobre un plano la distancia más corta entre dos puntos, la línea resultante no es una recta. Por ejemplo, así es como Delta Airlines muestra los vuelos que brinda en sociedad con Aerolíneas Argentinas:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/img/D_AA_destinos.jpg&#34; alt=&#34;Vuelos de Delta y Aerolíneas&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Vuelos de Delta y Aerolíneas&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Para reproducir esas curvas sobre el globo terráqueo, que llevan el simpático nombre de &lt;a href=&#34;https://es.wikipedia.org/wiki/Ortodr%C3%B3mica&#34;&gt;ortodrómicas&lt;/a&gt;, volvemos a recurrir al paquete &lt;code&gt;geosphere&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;curvas &amp;lt;- gcIntermediate(flights[c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;)], 
                         flights[c(&amp;quot;prev_lon&amp;quot;, &amp;quot;prev_lat&amp;quot;)])

maps::map(&amp;quot;world&amp;quot;, col=&amp;quot;#f2f2f2&amp;quot;, fill=TRUE, bg=&amp;quot;white&amp;quot;, lwd=0.15)#, xlim=xlim, ylim=ylim)

points(bind_rows(flights[, c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;)], 
             flights[, c(&amp;quot;prev_lon&amp;quot;, &amp;quot;lat&amp;quot;)]), 
       col = &amp;quot;red&amp;quot;)

for(i in 1:length(curvas)){
  lines(curvas[[i]], col = &amp;quot;orange&amp;quot;, lwd=2)
}

title( main = &amp;quot;:)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-10-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-iii_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;inflando-el-globo&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Inflando el globo&lt;/h1&gt;
&lt;p&gt;Por último, hagamos una proyección esférica. De paso podemos mostrar más información, como el año en que se efectuó cada vuelo, o la cantidad de veces que se pasó por un destino. Para ello, necesitamos (como siempre!) preparar nuestros datos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Generamos las coordenadas de las curvas/trayectos

curvas &amp;lt;- gcIntermediate(flights[,c(&amp;#39;prev_lon&amp;#39;, &amp;#39;prev_lat&amp;#39;)], 
                           flights[,c(&amp;#39;lon&amp;#39;, &amp;#39;lat&amp;#39;)], 
                           100, addStartEnd=TRUE, sp=TRUE)

# Convertimos las curvas (que son un &amp;quot;spatial object&amp;quot;) en una lista de dataframes que vamos a poder plotear

curvas &amp;lt;- map_df(curvas@lines, fortify)

# Agregamos la data de los vuelos

flights$index &amp;lt;- 1:nrow(flights)

curvas &amp;lt;- merge(curvas, flights, by.x = &amp;quot;id&amp;quot;, by.y = &amp;quot;index&amp;quot;, all.x = T)

# Acomodamos los datos de las ciudades para agregarlas a la visuaizacion
# Unimos las ciudades, sean origen o destino, en una sola lista

ciudades &amp;lt;- bind_rows(flights[c(&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;CITY_NAME&amp;quot;)] %&amp;gt;% 
                        setNames(c(&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;ciudad&amp;quot;)),
                      flights[c(&amp;quot;prev_lat&amp;quot;, &amp;quot;prev_lon&amp;quot;, &amp;quot;prev_city&amp;quot;)] %&amp;gt;% 
                        setNames(c(&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;ciudad&amp;quot;)))


ciudades &amp;lt;- ciudades %&amp;gt;%
  # Las coordenadas de las ciudades difieren enre registros, debido a difrentes 
  # posiciones exactas del usuario. Lo arreglamos...
  aggregate(data = ., cbind(lon, lat) ~ ciudad, FUN = function(x) mean(range(x))) %&amp;gt;% 
  # Agregamos frecuencia de visitas
  left_join(count(ciudades, ciudad)) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora si, generemos la visualización. Indicamos el año del vuelo mediante su color, y la cantidad de veces que el usuario pasó por una ciudad mediante el tamaño del punto que la representa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## Un globo terráqueo
library(hrbrthemes)
library(ggrepel)
ggplot() +
  borders(&amp;quot;world&amp;quot;, colour=&amp;quot;gray80&amp;quot;, fill=&amp;quot;gray95&amp;quot;) +
  # Graficamos los trayectos, diferenciando por año 
  geom_path(data = curvas, 
            aes(long, lat.x , 
                group = group, 
                color = as.factor(year)),
            size = 1.6,
            alpha = .85) +
  scale_color_brewer(palette = &amp;quot;YlGn&amp;quot;) +
  # Agregamos las ciudades
  geom_point(data=ciudades, aes(x = lon, y = lat, size = n), 
             shape = 16, alpha = .5) +
  # y etiquetas con los nombres
  geom_label_repel(data = ciudades, 
            aes(lon, lat, label = ciudad, angle = 10, 
                group = NULL), 
            size = 3) +
  # Centramos la proyección en el Océano Atlántico
  coord_map(&amp;quot;ortho&amp;quot;, orientation = c(10, -40, 0)) +
  labs(y = &amp;quot;&amp;quot;, x = &amp;quot;&amp;quot;,
       title=&amp;quot;Historial de ubicaciones de Google&amp;quot;,
       subtitle=&amp;quot;vuelos detectados&amp;quot;,
       color = &amp;quot;Año&amp;quot;,
       size = &amp;quot;Frecuencia&amp;quot;) +
  theme_ipsum() &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-10-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-iii_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;No luce nada mal.&lt;/p&gt;
&lt;p&gt;Para terminar, una simple conclusión: Google sabe demasiado sobre sus usuarios. Sería bueno pensar en como podemos remediarlo. No me refiero a “volver atrás” y dejar de usar tecnologías como el GPS y los registros de ubicación, sino a encontrar la forma de tomar control de nuestros datos, y tener el derecho a saber que se hace con ellos, limitando los usos que no nos convenzan.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Visualizando con R el historial de ubicaciones de Google (parte II)</title>
      <link>/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-ii/</link>
      <pubDate>Thu, 08 Jun 2017 00:00:00 +0000</pubDate>
      <author>avazquez@gmail.com (H. Antonio Vazquez Brust)</author>
      <guid>/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-ii/</guid>
      <description>&lt;p&gt;En la &lt;a href=&#34;https://bitsandbricks.github.io/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i/&#34;&gt;parte I&lt;/a&gt;, vimos cómo descargar, limpiar y comenzar a visualizar los datos de nuestra ubicación que Google guarda cuando usamos servicios de la compañía. Hasta aquí nos habíamos concentrado en clasificar los datos según el tiempo y según los países visitados.&lt;/p&gt;
&lt;p&gt;Ahora vamos a poner nuestra atención en el interior de las ciudades, para seguir los rastros que dejamos al recorrer las calles.&lt;/p&gt;
&lt;p&gt;Para reproducir los resultados, recomiendo correr antes el código de la &lt;a href=&#34;https://bitsandbricks.github.io/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i/&#34;&gt;parte I&lt;/a&gt;, que deja preparados los sets de datos que vamos a utilizar aquí.&lt;/p&gt;
&lt;div id=&#34;se-lo-que-hiciste-el-verano-pasado&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Se lo que hiciste el verano pasado&lt;/h2&gt;
&lt;p&gt;O al menos, lo se si puedo poner mis garras en tu historial de ubicaciones, lo cual no es tan fácil… a no ser que uno trabaje en Google o para los amigos de la NSA. En todo caso, volvamos al dataset que nos fue amablemente donado.&lt;/p&gt;
&lt;p&gt;Por el análisis que realizamos en la entrega anterior, sabemos que el usuario ha vivido en Buenos Aires y en Boston, y que ha visitado varias ciudades, entre ellas Nueva York. Vamos a empezar por visualizar sus movimientos en una ciudad donde está de visita. Cuando pasa unos días en una ciudad que ya conoce, siempre va a los mismo lugares?&lt;/p&gt;
&lt;p&gt;Vamos a responder esa pregunta aprovechando las funciones de &lt;code&gt;ggmap&lt;/code&gt;, que hacen muy pero muy fácil poner en pantalla un mapa de calles de cualquier lugar del mundo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(ggmap)
library(forcats)
library(hrbrthemes)
library(RColorBrewer)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Cargamos el dataset con el historial de ubicaciones, obtenido en  # https://bitsandbricks.github.io/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i/

locationdf &amp;lt;- read.csv(&amp;#39;/home/havb/data/Google/Location History/locationdf.csv&amp;#39;, 
                       stringsAsFactors = F)
class(locationdf$date) &amp;lt;- &amp;#39;POSIXct&amp;#39;

# Bajamos un mapa centrado en el Central Park de NY
NY  &amp;lt;- get_map(&amp;quot;Central Park, NY&amp;quot;, source = &amp;quot;stamen&amp;quot;, maptype = &amp;quot;toner-lite&amp;quot;, zoom = 12)

# Proyectamos el mapa
ggmap(NY) +
  # y trazamos por encima las coordenadas de cada ubicación del usuario registrada en el área
  geom_point(data = filter(locationdf, CITY_NAME == &amp;quot;New York&amp;quot;),
             aes(x = lon, y = lat, color = fct_inorder(paste(month, year))), 
             alpha = .5) +
  theme_ipsum() +
  scale_color_brewer(type = &amp;quot;qual&amp;quot;, palette = &amp;quot;Set2&amp;quot;) +
  labs(title=&amp;quot;Paradero del usuario&amp;quot;,
       color = &amp;quot;Fecha&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-08-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-ii_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;El mapa es claro, y muestra que en distintas ocasiones el usuario recorrió, en general, zonas diferentes de la ciudad. La mayor parte de su actividad transcurrió en Manhattan (en la visita de enero 2016 no abandonó la isla) con algunas visitas a New Jersey (al oeste del Río Hudson) y Brooklyn (al este del East River). En su última estadía se aventuró más al norte que de costumbre, pasando la mayor parte del tiempo en Harlem. Por la acumulación concentrada de puntos en ciertas parcelas, también es fácil deducir donde se ha alojado en cada ocasión.&lt;/p&gt;
&lt;p&gt;Lo interesante de un dataset con tanta resolución temporal y espacial es que podemos seguir al usuario cuando se mete dentro de los edificios. Por ejemplo, podemos saber si, y cuando, visita cualquiera de los destinos famosos en la ciudad. Por ejemplo, ¿alguna vez visito el Museo de Arte Moderno de Nueva York? Hagamos zoom en el MoMA, esta vez descartando los datos de latitud y longitud, que no hacen falta:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;MoMA &amp;lt;- get_map(&amp;quot;MOMA, NY&amp;quot;, zoom = 18)

ggmap(MoMA) + 
  geom_point(data = filter(locationdf, CITY_NAME == &amp;quot;New York&amp;quot;),
             aes(x = lon, y = lat, color = fct_inorder(paste(month, year))), 
             alpha = .7, size = 3)  +
  theme_ipsum() +
  scale_color_brewer(type = &amp;quot;qual&amp;quot;, palette = &amp;quot;Set2&amp;quot;) +
  labs(y = &amp;quot;&amp;quot;, x = &amp;quot;&amp;quot;,
       title=&amp;quot;¿Visitando el Museum of Modern Art?&amp;quot;,
       color = &amp;quot;Fecha&amp;quot;) +
  # Eliminamos las etiquetas de latitud y longitud de los ejes 
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank()) +
  coord_map()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-08-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-ii_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Bastante fácil de leer. En enero del 2016, y otra vez en enero año siguiente, se registran visitas al museo. De hecho, sabiendo las fechas y el ala del edificio visitada, hasta podríamos saber que obras fueron apreciadas. Según el calendario del MoMA, en enero del 2017 se exhibió &lt;a href=&#34;https://www.moma.org/calendar/exhibitions/1668&#34;&gt;“A Revolutionary Impulse: The Rise of the Russian Avant-Garde”&lt;/a&gt;. Hasta podemos ver como lucían las obras:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/img/MoMA.jpg&#34; alt=&#34;Exhibición en el MoMA, enero 2017&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Exhibición en el MoMA, enero 2017&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Podríamos verificar si el usuario pasó por cualquier otra atracción. O restaurantes en particular. Iglesias, supermercados, monumentos. Si visitó una zona roja o cualquier otra área con fama cuestionable, y cuanto tiempo pasó allí. Todo eso y mucho más está guardado en los servers de Google, y nosotros lo entregamos voluntariamente!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;buscando-un-hogar&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Buscando un hogar&lt;/h2&gt;
&lt;p&gt;Pasemos ahora a una ciudad donde el usuario tuvo o tiene su residencia permanente. Cuando uno usa Google Maps, tiene la opción de definir la dirección de su hogar. Lo interesante de asunto es que la empresa no necesita para nada que el usuario se lo diga; en todo caso, es una facilidad de cara al usuario, al que le queda su casa como una especie de &lt;em&gt;bookmark&lt;/em&gt; en el mapa. ¿Y porqué Google no necesita que se lo digamos?&lt;/p&gt;
&lt;p&gt;Bueno, primero veamos como lucen todos los registros de ubicación en la ciudad donde vive el usuario, Buenos Aires:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;BA  &amp;lt;- get_map(&amp;quot;Buenos Aires, Argentina&amp;quot;, source = &amp;quot;stamen&amp;quot;, maptype = &amp;quot;toner-lite&amp;quot;, zoom = 11)

ggmap(BA) + 
  geom_point(data = filter(locationdf, CITY_NAME == &amp;quot;Buenos Aires&amp;quot;),
             aes(x = lon, y = lat), 
             alpha = .1, color = &amp;quot;orange&amp;quot;) +
  theme_ipsum() +
  labs(y = &amp;quot;&amp;quot;, x = &amp;quot;&amp;quot;,
       title=&amp;quot;¿Dónde vive el usuario?&amp;quot;,
       subtitle = &amp;quot;versión difícil&amp;quot;) +
  # Eliminamos las etiquetas de latitud y longitud de los ejes 
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank()) +
  coord_map()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-08-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-ii_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Vemos que nuestro querido usuario ha estado por todos lados (salvo el sur-oeste de la ciudad, que parece ser &lt;em&gt;terra incognita&lt;/em&gt; para nuestro donante de datos), y que ha recorrido profusamente las arterias que comunican la ciudad con su área metropolitana. Pero no tenemos idea de donde vive, porque hay demasiado puntos sobre el mapa, y se hace imposible “leer” donde pasa la mayor parte de su tiempo.&lt;/p&gt;
&lt;p&gt;Vamos a recurrir a una técnica de visualización que se llama &lt;em&gt;hexagon binning&lt;/em&gt;, útil cuando lo que queremos es encontrar los lugares donde la intensidad de una variable se destaca. En éste caso, vamos a dividir el espacio de la cuidad en hexágonos, asignarle a cada uno un valor asociado a la frecuencia de registros realizados desde allí, y buscar los que muestren valores altos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(hexbin)

myPalette &amp;lt;- colorRampPalette(brewer.pal(7,&amp;#39;Oranges&amp;#39;))

ggmap(BA) + 
  coord_equal() +
  stat_binhex(aes(x = lon, y = lat), 
              binwidth = c(0.0075,0.0075), 
              alpha = .5, 
              data = locationdf) + 
  scale_fill_gradientn(colours=myPalette(7), name = &amp;quot;Cantidad de registros&amp;quot;) + 
  theme_ipsum() +
  labs(y = &amp;quot;&amp;quot;, x = &amp;quot;&amp;quot;,
       title=&amp;quot;¿Dónde vive el usuario?&amp;quot;,
       subtitle = &amp;quot;versión fácil&amp;quot;,
       fill = &amp;quot;Cantidad de registros&amp;quot;) +
  # Eliminamos las etiquetas de latitud y longitud de los ejes 
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-08-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-ii_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Bingo. El solitario hexágono de intensidad máxima señala el domicilio del usuario -o al menos, el lugar donde pasa la mayor parte de sus horas. Si hiciéramos zoom sobre el mapa podríamos ver la parcela donde vive, y por lo tanto su dirección exacta, pero nos vamos a abstener.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;descubriendo-habitos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Descubriendo hábitos&lt;/h2&gt;
&lt;p&gt;Podemos continuar usando la técnica de los hexágonos para buscar patrones. Por ejemplo, identificar los lugares donde el usuario es registrado con frecuencia, develando los centro de su actividad cotidiana. Haciendo un facetado por año, podemos incluso visualizar como “la vida cotidiana” cambia a lo largo del tiempo. Vamos a filtrar el dataset para considerar sólo registros de ubicación capturados durante el trajín de la semana: de 9 a 18, de lunes a viernes. Como notamos en la visualización anterior, los alrededores de la casa del usuario dominan el mapa. Para evitarlo en este mapa, vamos a aplicar un transformación logarítmica al conteo de ubicaciones, que tiene como efecto reducir la diferencia entre valores máximos y mínimos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(lubridate)

ggmap(BA) + 
  coord_equal() +
  stat_binhex(data = filter(locationdf, 
                           CITY_NAME == &amp;quot;Buenos Aires&amp;quot;, 
                           hour(with_tz(date, &amp;quot;America/Buenos Aires&amp;quot;)) &amp;gt; 9 &amp;amp;
                             hour(with_tz(date, &amp;quot;America/Buenos Aires&amp;quot;)) &amp;lt; 18,
                           wday(with_tz(date, &amp;quot;America/Buenos Aires&amp;quot;)) %in% 2:6),
              aes(x = lon, y = lat), 
              binwidth = c(0.0075, 0.0075), 
              alpha = .7) + 
  # Aplicamos una transformación logarítmica
  scale_fill_gradientn(colours=myPalette(9), trans = &amp;quot;log10&amp;quot;, name = &amp;quot;Location frequency&amp;quot;) +
  theme_ipsum() +
  labs(y = &amp;quot;&amp;quot;, x = &amp;quot;&amp;quot;,
       title=&amp;quot;Patrones de actividad diurna&amp;quot;) +
  # Eliminamos las etiquetas de latitud y longitud de los ejes 
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank()) +
  # y eliminamos la leyenda
  guides(fill = FALSE) +
  facet_wrap(~year)  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-08-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-ii_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Los resultados muestran una diferencia clara entre su actividad en los años 2011 y 2012, con una variedad de sitios visitados más reducida, en comparación con 2014 y 2015 cuando su rutina diaria parece haber sido mucho más variada. Su actividad está claramente concentrada en el área que corresponde al centro económico de la ciudad. Hace incursiones al exterior de la ciudad, hacia el norte, pero rara vez en otra dirección. En lo que va del 2017, sus radio de acción es notablemente más acotado: Su tiempo se reparte en dos regiones nítidamente demarcadas, sin presencia observable en otros sectores. En todo el año 2016 su celular no se reportó ni una sola vez desde los confines de la ciudad. Como ya habíamos notado en la &lt;a href=&#34;https://bitsandbricks.github.io/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i/&#34;&gt;parte I&lt;/a&gt; de ésta serie, estaba viviendo en otro país.&lt;/p&gt;
&lt;p&gt;Cómo planificador urbano, me causa vértigo imaginar todos los estudios que podríamos hacer sobre nuestras ciudades si tuviéramos acceso a la información que acumula Google: matrices origen/ destino de tránsito minuto a minuto, tendencias de actividad económica, recreativa, cultural, efecto en el tránsito peatonal y vehicular de cortes de servicio, cierre de calles y otros percances, estudios de adecuación del código de uso del suelo, e infinidad más. Claro que, aún más vértigo me da pensar todo lo que saben de nosotros, a nivel individual, no sólo Google sino los &lt;a href=&#34;http://www.telam.com.ar/notas/201312/44925-las-principales-revelaciones-de-edward-snowden.html&#34;&gt;servicios de inteligencia de los gobiernos que acceden a esos datos&lt;/a&gt;. En fin.&lt;/p&gt;
&lt;p&gt;En la próxima (y final) entrega, vamos a reproducir los viajes del usuario entre ciudades, mostrando como podemos reconstruir su historial de viajes aéreos en base a sus registros de ubicación. Y con una linda visualización, por supuesto… si vamos a espiar, lo haremos con estilo.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Visualizando con R el historial de ubicaciones de Google (parte I)</title>
      <link>/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i/</link>
      <pubDate>Wed, 07 Jun 2017 00:00:00 +0000</pubDate>
      <author>avazquez@gmail.com (H. Antonio Vazquez Brust)</author>
      <guid>/post/visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i/</guid>
      <description>&lt;p&gt;La irrupción de computadoras llenas de sensores que viajan el bolsillo de cada ciudadano -nuestros celulares- ha sido de sobra aprovechada por Google. Si no nos tomamos la molestia de inhabilitar funciones de localización activas de fábrica, todos los usuarios de celulares Android reportamos a Google nuestra posición, en forma constante. Y los usuarios de iPhones también, cuando usan servicios de la compañía en sus teléfonos.&lt;/p&gt;
&lt;p&gt;A esta altura, ya todos sabemos que Google es una compañía bastante &lt;em&gt;creepy&lt;/em&gt;. A cambio de unos cuantos servicios que hemos pasado a considerar imprescindibles, “sólo” quieren conocimiento completo de quiénes somos, qué hacemos, qué deseamos, y dónde estamos. Lo que Google hace con la cuantiosa información que acumula de sus miles de millones de usuarios es un misterio, al menos en cuanto a los detalles y al alcance de sus análisis.&lt;/p&gt;
&lt;p&gt;Por eso es interesante hacer algunos ejercicios por nuestra cuenta, visualizando los datos de localización que Google ha recopilado sobre nosotros. Interroguemos a la data con una pregunta general en mente: ¿Qué puede inferir Google acerca de mi si sabe donde estoy?&lt;/p&gt;
&lt;div id=&#34;descargando-nuestra-informacion-de-ubicacion&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Descargando nuestra información de ubicación&lt;/h2&gt;
&lt;p&gt;El primer paso es acceder a la información que Google dispone de nosotros. Entrando en &lt;a href=&#34;https://takeout.google.com/settings/takeout&#34; class=&#34;uri&#34;&gt;https://takeout.google.com/settings/takeout&lt;/a&gt; podemos descargar archivos comprimidos con la información personal que Google mantiene en sus distintos servicios. Para nuestros fines, solo necesitamos los datos de ubicación. De-seleccionamos todas las opciones, y activamos sólo “Location History” / “Historial de Ubicaciones”, en formato JSON:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/img/G_location_history.png&#34; alt=&#34;Google takeout&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Google takeout&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Cliqueando en “Siguiente” podemos iniciar la descarga.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;preparacion-de-los-datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Preparación de los datos&lt;/h2&gt;
&lt;p&gt;Una amable persona me ha donado su set de datos de ubicación para que juegue con ellos. Con el archivo de ubicaciones en nuestro poder, el impulso es generar visualizaciones de inmediato… pero como de costumbre, hay que masajear los datos para que queden utilizables.&lt;/p&gt;
&lt;p&gt;Primero convertimos el archivo JSON a un dataframe. Lo leemos como objeto de R usando la función &lt;code&gt;fromJSON&lt;/code&gt;, disponible en el paquete &lt;code&gt;jsonlite&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(jsonlite)
raw &amp;lt;- fromJSON(&amp;#39;../../../../data/Google/Location History/Location History.json&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generamos un dataframe con pares latitud/longitud más la fecha. Y de paso algunos datos extra, como velocidad, precisión del registro, dirección, altitud, y la actividad que Google supone que estábamos realizando (estar quietos, viajar a pie, en bici, otro vehículo, etc):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(lubridate)

locs &amp;lt;- raw$locations
locationdf &amp;lt;- data.frame(t=rep(0,nrow(locs)))

# convertimos lat y long a variables numéricas
locationdf$lat &amp;lt;- as.numeric(locs$latitudeE7/1E7)
locationdf$lon &amp;lt;- as.numeric(locs$longitudeE7/1E7)

# Nos llevamos los datos de precisión
locationdf$accuracy &amp;lt;- locs$accuracy

# Y la actividad más probable para cada lectura de posición
act &amp;lt;- map_df(locs$activity, 
              function(f) {
                if(is.null(f[[1]])) 
                  data.frame(activity=NA,confidence=NA,stringsAsFactors=F) 
                else 
                  data.frame(activity=f[[2]][[1]][[1]][1],
                             confidence=f[[2]][[1]][[2]][1],stringsAsFactors=F)
                })

# Agregar los datos de actividad a nuestro dataframe principal
locationdf$activity &amp;lt;- act$activity
locationdf$confidence &amp;lt;- act$confidence

# Velocity, altitude y heading también
locationdf$velocity &amp;lt;- locs$velocity
locationdf$altitude &amp;lt;- locs$altitude
locationdf$heading &amp;lt;- locs$heading

# Agregar un campo con fecha en calendario gregoriano, 
# y campos para día de la semana, mes y año
# El formato de la fecha es POSIX * 1000 (milliseconds) lo pasamos a una escala más útil...
locationdf$date &amp;lt;- as.numeric(locs$timestampMs)/1000
class(locationdf$date) &amp;lt;- &amp;#39;POSIXct&amp;#39;
locationdf$weekday &amp;lt;- weekdays(as.Date(locationdf$date))
locationdf$month &amp;lt;- months(as.Date(locationdf$date))
locationdf$year &amp;lt;- year(as.Date(locationdf$date))

# En el campo &amp;quot;activity&amp;quot; convertimos valores NA en &amp;quot;UNKNOWN&amp;quot;
locationdf$activity = ifelse(is.na(locationdf$activity), &amp;quot;UNKNOWN&amp;quot;, locationdf$activity)


# Agregar un indice y ordenarlo en reversa (el registro más reciente al final)
locationdf &amp;lt;- locationdf[rev(rownames(locationdf)),]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;primera-aproximacion-a-los-datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Primera aproximación a los datos&lt;/h2&gt;
&lt;p&gt;Para ir conociendo los datos, vamos a empezar con algo básico: Determinar que lapso de tiempo abarcan, y que tipo de “actividades” han sido registradas.&lt;/p&gt;
&lt;p&gt;Para que los &lt;em&gt;plots&lt;/em&gt; nos queden bonitos, usaremos los &lt;em&gt;themes&lt;/em&gt; credos por Bob Rudis, &lt;a href=&#34;https://hrbrmstr.github.io/hrbrthemes/&#34;&gt;“hrbrthemes”&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#devtools::install_github(&amp;quot;hrbrmstr/hrbrthemes&amp;quot;)
library(hrbrthemes)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y ahora, un &lt;a href=&#34;http://www.datavizcatalogue.com/methods/stacked_area_graph.html&#34;&gt;“stacked area chart”&lt;/a&gt;, para mostrar la evolución de la cantidad de registros capturados diariamente. Este tipo de visualización funciona bien cuando se quiere mostrar a lo largo del tiempo la contribución que distintas categorías hacen a un total.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Renombrar activity como actividad, crear campo con mes y año, agrupar por actividad + fecha
locationdf %&amp;gt;% 
  mutate(fecha = ymd(date(date))) %&amp;gt;% 
  group_by(activity, fecha) %&amp;gt;% 
  summarise(total = n()) %&amp;gt;% 
  arrange(fecha, activity, desc(total)) %&amp;gt;% 
  ggplot(aes(x=fecha, y=total)) + 
  geom_area(aes(fill=activity), position=&amp;quot;stack&amp;quot;) +
  scale_x_date() +
  ylim(c(0, 1750)) +
  labs(y=&amp;quot;registros&amp;quot;,
       title=&amp;quot;Historial de ubicaciones de Google&amp;quot;,
       subtitle=&amp;quot;Cantidad de registros por dia y por actividad&amp;quot;) +
  scale_fill_brewer(palette = &amp;quot;Set3&amp;quot;) +
  theme_ipsum()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-07-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;El gráfico indica que tenemos registros desde el 2011 hasta mediados del 2017. Durante los dos primeros años, los registros de ubicación fueron escasos. A fines del 2012 explota la frecuencia diaria de notificaciones a Google de la posición del usuario. Hay valles donde la frecuencia de registros baja notablemente, en 2013, 2014 y 2015. El del 2013 (la pendiente prolija) sin dudas parece resultado de un error u omisiones en la data… quizás Google también pierde datos cada tanto! Desde su apogeo en 2014 y 2015, con unos 1500 registros por día, parece ser que se han apiadado de la batería de nuestros celulares y los envíos de coordenadas a la madre nodriza no son tan constantes como antaño.&lt;/p&gt;
&lt;p&gt;En cuanto a las actividades registradas, “unknown” -desconocido- es la categoría más común. Le siguen “still” (o quieto), y mucho más lejos “tilting” (realizando un giro) y “on foot” (caminando). Es decir que para la gran mayoría de las veces que lee nuestra ubicación, Google sabe donde estamos pero no puede determinar de que modo nos movemos. Diría que en la práctica esto es compensado analizando registros de posición en conjunto: si un registro dado es identificado como “on foot” (por ejemplo) por el algoritmo que categoriza la actividad, otros registros donde la dirección y velocidad son más o menos constantes pueden considerarse parte de la misma secuencia de movimiento.&lt;/p&gt;
&lt;p&gt;Para visualizar cuantos registros aporta cada categoría en la suma total, intentemos con un “waffle chart”. Los gráficos de waffle son una alternativa a los gráficos de torta, que además de continuar con la nomenclatura gastronómica resultan, al menos en teoría, más fáciles de interpretar que sus primos circulares.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(waffle)

top5 &amp;lt;- locationdf %&amp;gt;% 
  filter(activity != &amp;quot;UNKNOWN&amp;quot;) %&amp;gt;% 
  group_by(activity) %&amp;gt;% 
  tally() %&amp;gt;% 
  arrange(desc(n)) %&amp;gt;% 
  slice(1:5)

# 1 cuadradito del waflle = 10000 registros
# De paso, conertimso el dataframe en un vector nombrado como quiere la funcion waffle()
top5 &amp;lt;- structure(top5[[2]] / 10000, names = top5[[1]])

waffle(top5,
       rows = 4,
       legend_pos = &amp;quot;bottom&amp;quot;,
       xlab = &amp;quot;1 cuadradito == 10.000 registros&amp;quot;,
       title = &amp;quot;Top 5 actividades identificadas&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-07-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Vemos que, al menos en cuanto a lo que ha podido establecer Google, el usuario es encontrado caminando en forma tres veces más habitual que a bordo de un vehículo. Por otro lado, “still” le gana por goleada a “on foot”, así que esa propensión a caminar es balanceada por cierto sedentarismo. Todo un mal de nuestros días, je. En todo caso las conclusiones deben ser tomadas con pinzas; estamos asumiendo que las actividades no identificadas (“unknown”) se reparten en la misma proporción que las etiquetadas.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;prestando-atencion-a-un-categoria-en-particular&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Prestando atención a un categoría en particular&lt;/h2&gt;
&lt;p&gt;Concentrémonos en los registros que encuentran al usuario caminando. Cuál es su día de mayor movimiento a pie?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;locationdf %&amp;gt;% 
  mutate(weekday = ordered(weekday, 
                           levels = c(&amp;quot;lunes&amp;quot;, &amp;quot;martes&amp;quot;, &amp;quot;miércoles&amp;quot;, &amp;quot;jueves&amp;quot;, 
                                      &amp;quot;viernes&amp;quot;, &amp;quot;sábado&amp;quot;, &amp;quot;domingo&amp;quot;))) %&amp;gt;% 
  filter(activity == &amp;quot;ON_FOOT&amp;quot;) %&amp;gt;% 
  count(weekday) %&amp;gt;% 
  mutate(pct=n/sum(n)) %&amp;gt;% 
  ggplot(aes(weekday, pct)) +
  geom_col() +
  scale_y_percent() +
  labs(x=&amp;quot;&amp;quot;, 
       y=&amp;quot;Porporción de los registros capturados por Google (%)&amp;quot;,
       title=&amp;quot;Movimiento a pie registrado&amp;quot;,
       subtitle=&amp;quot;según el día de la semana&amp;quot;) + 
  theme_ipsum(grid=&amp;quot;Y&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-07-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Para nuestro usuario donante, el viernes es el gran día para pasear (quizás de noche?), al igual que el fin de semana. El lunes, en cambio, registra los valores más bajos. Lunes de ánimo caído? Quizás no! Cada vez que visualizamos resúmenes de datos acumulados durante un período largo, es importante verificar que no se no esté escapando algo relacionado con el paso del tiempo. En este caso, la suma total por día de la semana podría estar ocultando diferencias claras entre distintos años. Peguemos una mirada, separando los registros por año:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;locationdf %&amp;gt;% 
  mutate(weekday = ordered(weekday, 
                           levels = c(&amp;quot;lunes&amp;quot;, &amp;quot;martes&amp;quot;, &amp;quot;miércoles&amp;quot;, &amp;quot;jueves&amp;quot;, 
                                      &amp;quot;viernes&amp;quot;, &amp;quot;sábado&amp;quot;, &amp;quot;domingo&amp;quot;))) %&amp;gt;% 
  filter(activity == &amp;quot;ON_FOOT&amp;quot;) %&amp;gt;% 
  count(weekday, year) %&amp;gt;% 
  mutate(pct=n/sum(n)) %&amp;gt;% 
  ggplot(aes(weekday, pct)) +
  geom_col() +
  facet_wrap(~year, scales = &amp;quot;free&amp;quot;) +
  labs(x=&amp;quot;&amp;quot;, 
       y=&amp;quot;Porporción anual de los registros capturados por Google&amp;quot;,
       title=&amp;quot;Movimiento a pie registrado&amp;quot;,
       subtitle=&amp;quot;según el día de la semana&amp;quot;) + 
  theme_ipsum(grid=&amp;quot;Y&amp;quot;) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text.y=element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-07-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Queda claro que el gráfico anterior resultaba engañoso. Si los datos de Google son confiables, nuestro usuario ha ido variando sus ritmos diarios con los años. En 2012 (y en el 2016 también) su día de paseo era el domingo. En lo que va del 2017, la mayor actividad de caminata se registra los miércoles.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;identificando-lugares&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Identificando lugares&lt;/h2&gt;
&lt;p&gt;Vamos ahora al grano. Al visualizar datos de ubicación, sin duda queremos ver lugares en el mapa! Para empezar, agreguemos un campo a nuestro dataset con la ciudad en la que fue efectuado cada registro. Esto es más complejo de lo que podría pensarse de inmediato, ya que la definición de “qué es” una ciudad varía entre regiones. También es difícil encontrar consenso acerca de las fronteras exactas de muchas de las miles de ciudades que en este mundo hay. Decidir a que ciudad corresponde un set de coordenadas puntual no debería ser muy complicado; pero escribir un algoritmo que lo haga en gran escala para coordenadas en cualquier lugar del globo es un desafío considerable.&lt;/p&gt;
&lt;p&gt;En este caso, estoy interesado en seguir los movimientos de un usuario mientras visita por trabajo o turismo distintas ciudades. Por eso no me preocupa saber el nombre de la localidad en la que se encuentre en cada momento, si no el de la ciudad principal de la región. La solución para el problema así definido:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Tomar una lista con la posición y la población de las ciudades del mundo&lt;/li&gt;
&lt;li&gt;Seleccionar aquellas que cuentan con una población considerable, digamos 100.000 habitantes&lt;/li&gt;
&lt;li&gt;Para cada ubicación registrada por Google, encontrar la ciudad más cercana de nuestra lista&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Es una de esas tareas que serían desesperantes para un ser humano, pero triviales par una computadora. Excelente.&lt;/p&gt;
&lt;p&gt;En &lt;a href=&#34;https://opendata.arcgis.com/datasets/6996f03a1b364dbab4008d99380370ed_0.csv&#34; class=&#34;uri&#34;&gt;https://opendata.arcgis.com/datasets/6996f03a1b364dbab4008d99380370ed_0.csv&lt;/a&gt; se puede descargar una base de datos de acceso libre y gratuito, que incluye (entre otros campos) nombre, código de país, latitud, longitud y población de las principales ciudades del mundo. Justo lo que necesitamos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cities &amp;lt;- read.csv(&amp;#39;/home/havb/data/World_Cities.csv&amp;#39;, stringsAsFactors = F) %&amp;gt;% 
  filter(POP &amp;gt; 100000)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Algo a tener en cuenta aquí es la performance del algoritmo que vamos a usar para encontrar la ciudad más cercana. Tenemos más de 1200 ciudades:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nrow(cities)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1231&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y más de 1.300.000 registros de ubicación:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nrow(locationdf)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1312415&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Usar un &lt;em&gt;loop&lt;/em&gt; “inocente” que compare cada registros contra todas las ciudades para encontrar la más cercana requeriría más de 1600 millones de operaciones. Está bien que la computadora no se cansa, pero el que se cansa es uno de esperar a que termine. Pero no hay nada que temer! Echaremos mano de un algoritmo muy eficiente para éste tipo de búsquedas, &lt;a href=&#34;https://es.wikipedia.org/wiki/K-vecinos_m%C3%A1s_cercanos&#34;&gt;K-nearest neighbors&lt;/a&gt; o Knn. En el mundo &lt;code&gt;R&lt;/code&gt; hay varias implementaciones de knn listas para usar. Vamos a usar la del paquete &lt;code&gt;SearchTrees&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(SearchTrees)

# Creamos un árbol de búsqueda con las posiciones definidas por las columnas de latitud y longitud 
tree &amp;lt;- createTree(cities, columns=c(2,1)) 

# Funcion para encontrar la ciudad mas cercanas a un punto dado

findMetro &amp;lt;- function(lat, lon, tree, cities) {
  return(cities[knnLookup(tree, lat, lon, k=1), c(&amp;quot;CITY_NAME&amp;quot;, &amp;quot;CNTRY_NAME&amp;quot;)])
}


# Encontrar el area metropolitana para cada registro

locationdf &amp;lt;- cbind(locationdf,
                    map2_df(locationdf$lat, locationdf$lon, 
                            findMetro, tree = tree, cities = cities))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Habiendo identificado cada ciudad, vale la pena agregar dos campos más que van a ser útiles para visualizar la data: país, y tiempo de estadía. Para calcular el tiempo de estadía, asignemos un identificador a cada secuencia de registros consecutivos efectuados en la misma ciudad usando &lt;a href=&#34;https://es.wikipedia.org/wiki/Run-length_encoding&#34;&gt;“run-lengh encoding”&lt;/a&gt; para luego extraer fecha de inicio y final de cada una. Agregar el país es fácil; sólo necesitamos hacer un &lt;em&gt;join&lt;/em&gt; contra una tabla de ciudades y naciones.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;runs &amp;lt;- rle(locationdf$CITY_NAME)
estadias &amp;lt;- locationdf %&amp;gt;% 
  mutate(run_id = rep(seq_along(runs$lengths), runs$lengths)) %&amp;gt;% 
  group_by(CITY_NAME, CNTRY_NAME, run_id) %&amp;gt;% 
  summarise(date_in = min(date),
            date_out = max(date)) %&amp;gt;% 
  arrange(date_in) %&amp;gt;% 
  select(-run_id) 

estadias&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 171 x 4
## # Groups:   CITY_NAME, CNTRY_NAME [28]
##    CITY_NAME             CNTRY_NAME date_in        date_out      
##    &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;      &amp;lt;dttm&amp;gt;         &amp;lt;dttm&amp;gt;        
##  1 Buenos Aires          Argentina  1301959888.636 1306159287.876
##  2 La Plata              Argentina  1306159479.886 1306192359.628
##  3 Buenos Aires          Argentina  1306193665.488 1307719425.635
##  4 La Plata              Argentina  1307719623.741 1307748874.83 
##  5 Buenos Aires          Argentina  1307765657.954 1312817838.016
##  6 Salta                 Argentina  1312828736.928 1312995091.661
##  7 San Miguel De Tucuman Argentina  1312997048.009 1313106833.44 
##  8 Buenos Aires          Argentina  1313113824.791 1317501265.995
##  9 La Plata              Argentina  1317827208.834 1317830169.106
## 10 Buenos Aires          Argentina  1317831680.811 1317831887.856
## # ... with 161 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Con la data prolija, es fácil hacer un ranking de tiempo pasado en cada ciudad…:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ranking &amp;lt;- estadias %&amp;gt;% 
  mutate(semanas = difftime(date_out,
                         date_in,
                         units = &amp;quot;weeks&amp;quot;)) %&amp;gt;% 
  group_by(CITY_NAME, CNTRY_NAME) %&amp;gt;% 
  summarise(total_semanas = round(sum(semanas), 1)) %&amp;gt;% 
  arrange(desc(total_semanas))
ranking&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 28 x 3
## # Groups:   CITY_NAME [28]
##    CITY_NAME       CNTRY_NAME     total_semanas
##    &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;          &amp;lt;time&amp;gt;       
##  1 Buenos Aires    Argentina      185.5        
##  2 Boston          United States  83.3         
##  3 New York        United States  4            
##  4 Cordoba         Argentina      0.9          
##  5 La Plata        Argentina      0.9          
##  6 Frankfurt       Germany        0.7          
##  7 Rosario         Argentina      0.7          
##  8 Reykjavik       Iceland        0.6          
##  9 Birmingham      United Kingdom 0.5          
## 10 Washington D.C. United States  0.5          
## # ... with 18 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;… y un mapa de países visitados y duración total de estadías:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rworldmap)
# Preparar la data

toMap &amp;lt;- joinCountryData2Map(ungroup(ranking),
                             joinCode = &amp;quot;NAME&amp;quot;,
                             nameJoinColumn = &amp;quot;CNTRY_NAME&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 28 codes from your data successfully matched countries in the map
## 0 codes from your data failed to match with a country code in the map
## 233 codes from the map weren&amp;#39;t represented in your data&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# A mapear!
library(RColorBrewer)

mapCountryData(toMap, 
               nameColumnToPlot = &amp;quot;total_semanas&amp;quot;,
               catMethod = &amp;quot;pretty&amp;quot;,
               colourPalette = brewer.pal(5, &amp;quot;YlGn&amp;quot;), 
               oceanCol= &amp;quot;lightblue&amp;quot;, 
               missingCountryCol= &amp;quot;grey40&amp;quot;,
               mapTitle= &amp;quot;Estadía total (semanas)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-07-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Por último, tracemos una línea de tiempo que siga el derrotero de nuestro usuario. Es fácil detectar cuando se muda:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(timeline)

estadias &amp;lt;- estadias %&amp;gt;% 
  mutate(tipo = ifelse(difftime(date_out, date_in, units = &amp;quot;weeks&amp;quot;) &amp;gt;= 3,
                       &amp;quot;residencia&amp;quot;,
                       &amp;quot;visita&amp;quot;)) %&amp;gt;% 
  as.data.frame

timeline(filter(estadias, tipo == &amp;quot;residencia&amp;quot;),
         filter(estadias, tipo == &amp;quot;visita&amp;quot; )[c(1,3)],
         text.size = 0, group.col = &amp;quot;tipo&amp;quot;, 
         event.label.method = 2, event.text.size = 2) + 
  theme_ipsum() + 
  scale_fill_ipsum(name = &amp;quot;Residencia&amp;quot;) + 
  labs(x=&amp;quot;año&amp;quot;, 
       y=&amp;quot;&amp;quot;,
       title=&amp;quot;Ciudad de residencia y ciudades visitadas&amp;quot;,
       subtitle = &amp;quot;Inferencia según registros de ubicación de Google&amp;quot;,
       caption = &amp;quot;cada punto representa una visita&amp;quot;) +
  theme(axis.text.y=element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-07-visualizando-con-r-el-historial-de-ubicaciones-de-google-parte-i_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;720&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Hay algunos problemas con esta visualización: La nube de puntos que representa ciudades visitadas es difícil de leer, e incluye en algunos casos la ciudad donde se supone que el usuario reside. Esto último se debe a que definimos una “visita” como cualquier estadía menor a un mes. Cuando el usuario pasa unas pocas semanas en su casa debido a viajes frecuentes, ese periodo aparece como si hubiera estado de visita en nuestro gráfico. De todas formas, para un puñado de líneas de código los resultados son interesantes, y de hecho permiten hacerse una buena idea de los desplazamientos del usuario. Y si lo vemos nosotros con tanta facilidad, desde ya que Google lo sabe desde hace tiempo.&lt;/p&gt;
&lt;p&gt;En la parte II, vamos a hacer zoom a nivel ciudad para perseguir más a nuestro pobre usuario, tratando de identificar donde vive, donde trabaja y como cambia su conducta según el día de la semana. Pero todo con benévolas intenciones, por supuesto.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
